<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SEIDR</name>
    </assembly>
    <members>
        <member name="M:SEIDR.BaseExtensions.GetDescription(System.Reflection.MemberInfo)">
            <summary>
            Gets the description of the specified MemberInfo
            </summary>
            <param name="val"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.GetDescription(System.Enum)">
            <summary>
            Tries to get the enum's description, or the name of the value if no description specified
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.NullifyStringProperties(System.Object)">
            <summary>
            For any string properties on the object, set them to null if they're white space or empty
            </summary>
            <param name="j"></param>
        </member>
        <member name="M:SEIDR.BaseExtensions.DeNullifyStrings(System.Object)">
            <summary>
            For any readable and writable string properties on the object, check if they're null. If so, set them to be an empty string instead
            </summary>
            <param name="j"></param>
        </member>
        <member name="M:SEIDR.BaseExtensions.nLength(System.String)">
            <summary>
            Returns the length of the string, or -1 if null.
            </summary>
            <param name="check"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.SplitOnString(System.String,System.String)">
            <summary>
            Splits the string on the split string instead of
            </summary>
            <param name="check"></param>
            <param name="split"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.Matches``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0})">
            <summary>
            Compares each sequence of list left with the corresponding entry in right using <see cref="M:System.Object.Equals(System.Object)"/>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.IsSuperSet``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Checks that every item of the sublist is contained in the main list
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="subList"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.IsSubset``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Checks if the list is a super set of sublist
            </summary>
            <typeparam name="T"></typeparam>
            <param name="subList"></param>
            <param name="list"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.Union``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Boolean)">
            <summary>
            Unions the enumerables and returns an IList
            </summary>
            <typeparam name="T"></typeparam>
            <param name="left"></param>
            <param name="right"></param>
            <param name="distinct">If true, will only add items from right to left if they are not already contained in left</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.ntLength(System.String)">
            <summary>
            Returns the length of the trimmed string, or -1 if null
            </summary>
            <param name="check"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.nTrim(System.String)">
            <summary>
            Null safe version of Trim.
            <para>
            Returns an empty string if null.
            </para>
            </summary>
            <param name="check"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.nTrim(System.String,System.Boolean)">
            <summary>
            Null safe version of Trim.
            <para>
            If nullify is true, returns null instead of an empty string.
            </para>
            Else acts the same as nTrim with no boolean
            </summary>
            <param name="check"></param>
            <param name="nullify"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.nString(System.String)">
            <summary>
            Returns null if the trimmed string is empty.
            <para>
            Otherwise, returns the string
            </para>
            </summary>
            <param name="check"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.Like(System.String,System.String,System.Boolean)">
            <summary>
            Check if string a is like string b
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="escapeRegularExpressions">If set to false, will allow making use of regular expressions included in string a or b for doing the comparison..</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.Include``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>
            Returns a new IEnumerable including the new record(s) via a union
            </summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="toInclude"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.FirstMatch(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean)">
            <summary>
            Gets the first match from the list that matches the LIKE expression
            </summary>
            <param name="list"></param>
            <param name="LIKE"></param>
            <param name="EscapeRegex"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.LastMatch(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean)">
            <summary>
            Returns the last match from the list that matches the LIKE expression
            </summary>
            <param name="list"></param>
            <param name="LIKE"></param>
            <param name="escapeRegularExpressions"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.AllMatches(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean)">
            <summary>
            Alias for <see cref="M:SEIDR.BaseExtensions.Like(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean)"/>
            </summary>
            <param name="list"></param>
            <param name="LIKE"></param>
            <param name="escapeRegularExpressions"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.Like(System.Collections.Generic.IEnumerable{System.String},System.String,System.Boolean)">
            <summary>
            Returns an IEnumerable containing only the strings that are 'Like' b
             </summary>              
        </member>
        <member name="M:SEIDR.BaseExtensions.TakeSubset``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>
            Takes a subset of the ordered list and returns a new IList containing the values that match the selector
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="selector"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.AddRangeLimited``1(System.Collections.Generic.List{``0},System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Adds the range to the list. 
            <para>If the range would increase the count above the limit, then will only insert part of the range
            </para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="aList"></param>
            <param name="range"></param>
            <param name="limit"></param>
        </member>
        <member name="M:SEIDR.BaseExtensions.NotIn``1(``0,``0[])">
            <summary>
            Short circuit after finding a match to return false. Opposite of In
            </summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <param name="list"></param>
            <returns>True if the list does not contain obj. False if obj is found in the list.</returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.Between(System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Returns true if <paramref name="x"/> is between <paramref name="a"/> and <paramref name="b"/>.
            </summary>
            <param name="x"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="inclusive">If true, will return true when <paramref name="x"/> is equal to <paramref name="a"/> or <paramref name="b"/>. Otherwise, will return false in these cases.</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.Between(System.Int64,System.Int64,System.Int64,System.Boolean)">
            <summary>
            Returns true if <paramref name="x"/> is between <paramref name="a"/> and <paramref name="b"/>.
            </summary>
            <param name="x"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="inclusive">If true, will return true when <paramref name="x"/> is equal to <paramref name="a"/> or <paramref name="b"/>. Otherwise, will return false in these cases.</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.Between(System.Int16,System.Int16,System.Int16,System.Boolean)">
            <summary>
            Returns true if <paramref name="x"/> is between <paramref name="a"/> and <paramref name="b"/>.
            </summary>
            <param name="x"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="inclusive">If true, will return true when <paramref name="x"/> is equal to <paramref name="a"/> or <paramref name="b"/>. Otherwise, will return false in these cases.</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.Between(System.Byte,System.Byte,System.Byte,System.Boolean)">
            <summary>
            Returns true if <paramref name="x"/> is between <paramref name="a"/> and <paramref name="b"/>.
            </summary>
            <param name="x"></param>
            <param name="a"></param>
            <param name="b"></param>
            <param name="inclusive">If true, will return true when <paramref name="x"/> is equal to <paramref name="a"/> or <paramref name="b"/>. Otherwise, will return false in these cases.</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.Exists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Checks that there is any record in <paramref name="list"/> that matches <paramref name="check"/>. Returns early on finding a match.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="check"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.SplitByKeyword(System.String,System.String,System.Boolean,System.Boolean)">
            <summary>
            Splits the string by a single keyword
            </summary>
            <param name="value"></param>
            <param name="KeyWord"></param>
            <param name="includeKeyword">Incldue the keyword in the resulting IEnumerable</param>
            <param name="IgnoreCase">If true, ignores the cases of value and KeyWord</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.SplitByKeyword(System.String,System.Collections.Generic.IEnumerable{System.String},System.Boolean,System.Boolean)">
            <summary>
            
            </summary>
            <param name="value"></param>
            <param name="KeyWords"></param>
            <param name="IncludeKeywords">If true, include the keywords in the Enumerable. If False, leave them out.</param>
            <param name="IgnoreCase">If true, ignores the cases of value and KeyWord</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.IndexOfAny(System.String,System.Collections.Generic.IEnumerable{System.String},System.Int32,System.String@,System.Boolean)">
            <summary>
            First index of any of the keywords that occurs at or after start.
            <para>Returns -1 if no match found</para>
            </summary>
            <param name="value"></param>
            <param name="words"></param>
            <param name="start"></param>
            <param name="Chosen">The keyword that found the index</param>
            <param name="CaseInsensitive">Ignore case when doing comparison</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.HasMinimumCount``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Lazy check to make sure that an IEnumerable has at least <paramref name="minimum"/> records.
            <para>Empty IEnumerables will always return false.</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="minimum">Must be at least 1 to be useful - null/empty IEnumerables will always return false</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.OrderedMap``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Maps the dictionary to an ordered enumerable
            </summary>
            <typeparam name="T"></typeparam>
            <typeparam name="K"></typeparam>
            <param name="dictionary"></param>
            <param name="orderSelection">Determines order that values are grabbed from the dictionary.<para>
            If a record does not exist as a key, the default of <typeparamref name="T"/> will be returned</para></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.MapInto``2(System.Collections.Generic.IList{``1},System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IList{``0})">
            <summary>
            Maps the values into the dictionary to populate the value of the corresponding key by ordinal position
            </summary>
            <typeparam name="K"></typeparam>
            <typeparam name="T"></typeparam>
            <param name="Keys"></param>
            <param name="values"></param>
            <param name="destination"></param>
        </member>
        <member name="M:SEIDR.BaseExtensions.UnderMaximumCount``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Lazy check to make sure that an IENumerable has less than <paramref name="maximum"/> records. (Returns immediately after confirming that we're above the count)
            <para>Empty IEnumerables will always return true.</para>
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="maximum"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.NotExists``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>
            Reverse from exists, but exits early on finding a match.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="check"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.AndNot(System.Boolean,System.Boolean)">
            <summary>
            returns true if a and not b. False A or true b will result in false
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.CrossApply``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Action{``0})">
            <summary>
            Takes an IEnumerable and applies method 'Apply' to every item that fits the predicate. Other items are excluded from the result.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="Predicate"></param>
            <param name="Apply"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.CrossApply``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Cross apply with an action that can return more records.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="Predicate"></param>
            <param name="Apply"></param>
            <returns>Returns results of calling apply on the list members that match Predicate</returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.OuterApply``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Action{``0})">
            <summary>
            Takes an IEnumerable and applies method 'Apply' to every item that fits the predicate. Other items are left 'As-Is', but included in the result.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="Predicate"></param>
            <param name="Apply"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.BaseExtensions.OuterApply``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean},System.Func{``0,System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            
            </summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="Predicate"></param>
            <param name="Apply"></param>
            <returns>List Members that don't match predicate combined with result of applying function to members that do match</returns>
        </member>
        <member name="T:SEIDR.BigValueFlag">
            <summary>
            Class for holding a very large number of flags somewhat like a zero based array of bools initialized to false
            </summary>
        </member>
        <member name="M:SEIDR.BigValueFlag.GetEnumerator">
            <summary>
            Enumerate through the flagged values
            <para>NOTE: Because of the way values are stored internally, this will probably not be in the same order that the values were flagged.</para>
            <para>Ex: See the debug console output of BigValueFlagTest's method 'BigValueFlagEnumeratorTest' from the Unit test project</para>
            <para>Values *will* be contiguous in chunks of 64, though. I.e., if 1 and 2 and 63 are flagged, 1 is always before 2 and 2 always before 63 in this method's output.</para>
            </summary>
            <returns></returns>
        </member>
        <member name="P:SEIDR.BigValueFlag.Item(System.UInt64)">
            <summary>
            Checks if a value has been flagged as true or false.<para>Set: flips/unflips the value.</para>
            </summary>
            <param name="check"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.BigValueFlag.MaxFlagged">
            <summary>
            Gets the largest flag value, or null if nothing is flagged
            </summary>
        </member>
        <member name="P:SEIDR.BigValueFlag.MinFlagged">
            <summary>
            Gets the minimum value that has been flagged, or null if nothing is flagged
            </summary>
        </member>
        <member name="P:SEIDR.BigValueFlag.Count">
            <summary>
            Returns the number of flagged (true) records. Will not overflow
            </summary>
        </member>
        <member name="P:SEIDR.BigValueFlag.BigCount">
            <summary>
            Returns the number of flagged (true) records
            </summary>
        </member>
        <member name="M:SEIDR.BigValueFlag.Clear">
            <summary>
            Resets all values to false.
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManagerExtensions.CheckOutput">
            <summary>
            Flag Parameter direction to determine if the value needs to be checked after execution
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerExtensions.GetMappedName(System.Reflection.PropertyInfo)">
            <summary>
            Returns the mapped name (by FieldMapping attribute), or the property's actual name if there is no populated mapping.
            </summary>
            <param name="prop"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerExtensions.GetGetters(System.Type)">
            <summary>
            Returns a dictionary of the mapped property names and their getMethods
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerExtensions.MappingIgnored(System.Reflection.PropertyInfo,System.Boolean)">
            <summary>
            Checks if the property should be ignored by the DatabaseManager when working with SqlParameters
            </summary>
            <param name="prop"></param>
            <param name="forOutParameter">Ignores the mapping only when checking Out Parameters for their updated values</param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.DataBase.DatabaseManagerIgnoreMappingAttribute">
            <summary>
            Tells the DatabaseManager to ignore a mapping. Should only be used if there's a default value
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerIgnoreMappingAttribute.ignoreSet">
            <summary>
            Ignore setting the value in parameters when populating the SqlCommand's parameters if the direction to ignore is either <see cref="F:System.Data.ParameterDirection.Input"/> or <see cref="F:System.Data.ParameterDirection.InputOutput"/>
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerIgnoreMappingAttribute.ignoreReadOut">
            <summary>
            Ignore reading the output parameters of the SqlCommand after execution if the direction to ignore is <see cref="F:System.Data.ParameterDirection.InputOutput"/>, <see cref="F:System.Data.ParameterDirection.Output"/>, or <see cref="F:System.Data.ParameterDirection.ReturnValue"/>
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerIgnoreMappingAttribute.#ctor(System.Data.ParameterDirection)">
            <summary>
            Tells DatabaseManager to ignore the parameter for the specified direction
            </summary>
            <param name="directionToIgnore"></param>
        </member>
        <member name="T:SEIDR.DataBase.DatabaseManagerFieldMappingAttribute">
            <summary>
            Changes the name for properties by the DatabaseManager when doing any mappings from/to objects
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManagerFieldMappingAttribute.MappedName">
            <summary>
            Name to be used by DatabaseManagers
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerFieldMappingAttribute.#ctor(System.String)">
            <summary>
            Maps the property to a different name for use in DatabaseManager mappings
            </summary>
            <param name="Map">Name to use. Note: This value will be trimmed and set to null if empty. If a property should be ignored in mapping, use the DatabaseManagerIgnoreMapping attribute</param>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.RethrowException">
            <summary>
            Provide a value to override the value from DatabaseManager
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.connection">
            <summary>
            Allow maintaining a SQL Connection across commands until the HelperModel is disposed
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.ExpectedReturnValue">
            <summary>
            If a value is set - output parameters will not be updated if ReturnValue doesn't match.
            <para>If a transaction is open and the return value doesn't match, it will also rollback automatically</para>
            <para>Otherwise, does nothing, and will not cause any exception to be thrown.</para>
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.SetPropertyIgnore(System.String[])">
            <summary>
            Resets the list of Properties to ignore to be the provided string array
            </summary>
            <param name="PropertyList"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.ResetKeys(System.Collections.Generic.Dictionary{System.String,System.Object})">
            <summary>
            Removes existing parameter key/value pairs and sets it the provided Dictionary
            </summary>
            <param name="ParameterKeys">New value for extra parameter list... Null is okay</param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.AddDataRowAsKeys(System.Data.DataRow)">
            <summary>
            Converts a DataRow from a table to Parameter Key/values
            </summary>
            <param name="r"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.AddKey(System.String,System.Object)">
            <summary>
            Calls Dictionary Add on the underlying key dictionary
            </summary>
            <param name="Name"></param>
            <param name="value"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.RemoveKey(System.String)">
            <summary>
            Removes the key if it exists.
            </summary>
            <param name="Key"></param>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.QualifiedProcedure">
            <summary>
            Qualified procedure name, containing the schema + Procedure.
            <para>If Schema has not been set, dbo will be used.</para>
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManagerHelperModel.ParameterMap">
            <summary>
            Contains readable properties that should be mapped to SQL parameters
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.Schema">
            <summary>
            Allow overridding the Default Schema from the Database Connection manager. 
            <para>If null or empty, the Schema from DatabaseConnectionManager will be used, but dbo will be returned in 'QualifiedProcedure' property, if used separately
            </para>
            <para>Removes brackets and quotes, due to the way the manager uses it for schema</para>
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.Procedure">
            <summary>
            Procedure to be called. Quotes will be removed and the string surrounded with brackets.
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.PropertyIgnore">
            <summary>
            List of properties to ignore from the parameterMap (Ignored parameters will use the default value)
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManagerHelperModel.Item(System.String)">
            <summary>
            Add/Get Key-Value pairs for SQL parameters - will override properties from parameter map. 
            <para>Any new keys will also be added to PropertyIgnore</para>
            </summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.BeginTran">
            <summary>
            Begins a transaction on the set connection
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.RollbackTran">
            <summary>
            Rolls back the transaction and then disposes it. Require open transaction/connection
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.CommitTran">
            <summary>
            Commits the transaction and then disposes it. Requires open transaction/connection.
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManagerHelperModel.ClearTran">
            <summary>
            Removes the transaction by calling dispose, if not null. Resets the IsRolledBack variable
            </summary>        
        </member>
        <member name="T:SEIDR.DataBase.DatabaseConnection">
            <summary>
            Wrapper class for managing a SQL server connection and running some common queries..
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseConnection.FromString(System.String)">
            <summary>
            Construct an object using a connection string.
            </summary>
            <param name="connectionString"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.Timeout">
            <summary>
            If the value is >= 0, will specify the timeout in the connection string.
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.CommandTimeout">
            <summary>
            If value is >= 0, will set the Command timeout in SQL commands when run by this class's RunCommand. Default is -1 (Does not change the command timeout).
            <para>Outisde of the class, returns 30 if the internal value is &lt; 0</para>
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.ApplicationName">
            <summary>
            Application Name for the connection. (E.g., seen when calling sp_who2)
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseConnection.DEFAULT_NAME">
            <summary>
            Default name for use in the connection manager
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseConnection.#ctor">
            <summary>
            Constructor that does not set values.
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseConnection.DEFAULT_DBNAME">
            <summary>
            The database connected to if one is not specified
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.Password">
            <summary>
            Password for non trusted authentication. Must be set outside of constructor
            <para>Should probably only use for logins with limited access, e.g. a dev password with basically read only access or something</para>
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.UserName">
            <summary>
            Username for non trusted authentication. Must be set outside of constructor
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.useTrustedConnection">
            <summary>
            Gets whether or not the connection uses a UserName/Password to log in vs Windows authentication
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.Server">
            <summary>
            Gets or sets the SQL Server to connect to
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.DefaultCatalog">
            <summary>
            Sets the Default database to connect to. If missing, will return string.Empty
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.FailoverPartner">
            <summary>
            Specifies that there is a mirroring database that can be passed to the connection.
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.ConnectionString">
            <summary>
            Returns the connection string based on properties of this  object
            </summary>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseConnection.IsValid">
            <summary>
            Returns whether the set up is valid - Connection string will not be returned if this is false
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseConnection.RunCommand(System.Data.SqlClient.SqlCommand,System.Boolean)">
            <summary>
            Run the command with this Connection
            </summary>
            <param name="cmd"></param>
            <param name="Dispose">If true, dispose the sql command after getting results</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseConnection.RunCommand(System.Data.SqlClient.SqlCommand,System.Data.SqlClient.SqlConnection,System.Boolean)">
            <summary>
            Runs the sql command on the passed sqlconnection. SQLConnection will be closed if it was unopened when passed. 
            <para>SQL Command will be disposed if <paramref name="Dispose"/> is true</para>
            </summary>
            <param name="cmd"></param>
            <param name="c"></param>
            <param name="Dispose"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.ToContentList``1(System.Data.DataTable)">
            <summary>
            Converts datatable to a list of objects of type RT. Returns null if the datatable passed is null.
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.ToContentRecord``1(System.Data.DataSet,System.Int32,System.Int32)">
            <summary>
            If the specified table is in the DataSet and contains a row at the specified index, returns a new record of type <typeparamref name="RT"/>.
            <para>Else, returns the default for the type.</para>
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="ds"></param>
            <param name="TableIndex"></param>
            <param name="RowIndex"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.ToContentRecord``1(System.Data.DataTable,System.Int32)">
            <summary>
            If the specified row is in the Datatable, returns a new record of type <typeparamref name="RT"/>.
            <para>Else, returns the default for the type.</para>
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.ToContentRecord``1(System.Data.DataRow)">
            <summary>
            Returns a new copy of type <typeparamref name="RT"/>. 
            If the passed DataRow is null, returns default for the Type.
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="row"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.MapEachColumn(System.Data.DataRow,System.Func{System.Data.DataColumn,System.Object})">
            <summary>
            Applies mapping function to each column of the row. Ignores any existing values
            </summary>
            <param name="r"></param>
            <param name="map"></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.MapEachColumn(System.Data.DataRow,System.Func{System.Data.DataColumn,System.Object,System.Object})">
            <summary>
            Applies mapping function to each column of the row
            </summary>
            <param name="r"></param>
            <param name="mapUpdate"> Mapping function that can consider any existing value in the column</param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.GetFirstTableOrNull(System.Data.DataSet)">
            <summary>
            Returns the first table from the dataset, or null if there are no tables.
            </summary>
            <param name="ds"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.GetFirstRowOrNull(System.Data.DataTable)">
            <summary>
            Returns first row of the dataTable, if it has any rows. Else returns null.
            </summary>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.GetFirstRowOrNull(System.Data.DataSet)">
            <summary>
            Returns first row of the first table, or null if there there is none.
            </summary>
            <param name="ds"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.GetFirstRowOrNull(System.Data.DataSet,System.Int32)">
            <summary>
            Returns the first row of the specified Table, if the dataset contains that many tables
            </summary>
            <param name="ds"></param>
            <param name="Table">Zero based index of the table to be grabbed</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.GetTableOrNull(System.Data.DataSet,System.Int32)">
            <summary>
            Return table at zero based index or null
            </summary>
            <param name="ds"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseExtensions.GetReturnValue(System.Data.SqlClient.SqlCommand)">
            <summary>
            Gets the Return value of the command. If no return value is set, return 0.
            </summary>
            <param name="cmd"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.DataBase.DatabaseManager">
             <summary>
             Sets up a database manager to handle converting c# objects to SQL parameters.
             <para>Can also be used for populating c# objects with results of procedures which could also have had its parameters populated by an object(generic)
            </para>
             </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.GetBasicHelper(System.Boolean)">
            <summary>
            Returns the default Helper Model for this connection.
            </summary>
            <param name="includeConnection">If true, sets the SQL connection using this manager's connection</param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManager.DefaultRetryOnDeadlock">
            <summary>
            When inferring a procedure call model, allows overriding the default setting for Retry on Deadlock
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.#ctor(SEIDR.DataBase.DatabaseConnection,System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
             <summary>
             Sets up a database manager to handle converting c# objects to SQL parameters.
             <para>Can also be used for populating c# objects with results of procedures which could also have had its parameters populated by an object(generic)
            </para>
             </summary>
             <param name="Connection">The database Connection for storing SQL connection info</param>
             <param name="DefaultSchema">Default Schema to be used when not overridden in any of the versions of the procedures/ when using a ConnectionParameterInfo object</param>
             <param name="SaveFormat">Format to be used in <see cref="!:Save&lt;RT&gt;(RT, string, string[])"/>. Object type name replaces {0}</param>
             <param name="UpdateFormat">Format to be used in <see cref="!:Update&lt;RT&gt;(RT, string, string[])"/>. Object type name replaces {0}</param>
             <param name="InsertFormat">Format to be used in <see cref="!:Insert&lt;RT&gt;(RT, string, string[])"/>. Object type name replaces {0}</param>
             <param name="DeleteFormat">Format to be used in <see cref="!:Delete&lt;RT&gt;(RT, string, string[])"/>. Object type name replaces {0}</param>
             <param name="SelectRowFormat">Format to be used in <see cref="!:SelectSingle&lt;RT&gt;(object, string, string[])"/>. Object type name replaces {0}</param>
             <param name="SelectListFormat">Format to be used in <see cref="!:SelectList&lt;RT&gt;(object, string, string[])"/>. Object type name replaces {0}</param>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManager.ProgramName">
            <summary>
            Overrides the Application Name of the DatabaseConnection when starting new connections
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.Clone(System.Boolean,System.String)">
            <summary>
            Clones the DatabaseManager, but takes the setting of Rethrow from the parameter.
            </summary>
            <param name="reThrowException"></param>
            <param name="programName">If non-null, overrids the value of the cloned manager's program name</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.GetConnection">
            <summary>
            Returns a new sql connection using the underlying <see cref="T:SEIDR.DataBase.DatabaseConnection"/>
            </summary>
            <returns></returns>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManager.DefaultSchema">
            <summary>
            Sets the default schema - used when parameters are not passed to methods to override the schema. 
            <para>[ and ] are removed, but will be added around the schema when actually performing the call</para>
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.DEFAULT_SAVE">
            <summary>
            Default format for combined "Insert/Update" procedure calls
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.DEFAULT_UPDATE">
            <summary>
            Default format for "Update" procedure call
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.DEFAULT_INSERT">
            <summary>
            Default format for "Insert" procedure call
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.DEFAULT_DELETE">
            <summary>
            Default format for "Delete" procedure call
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.DEFAULT_SELECT_ROW">
            <summary>
            Default format for "Select single" procedure call
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.DEFAULT_SELECT_LIST">
            <summary>
            Default format for "Select list" procedure call - multiple row result from the first DataTable
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.SaveFormat">
            <summary>
            Format for a procedure that handles both inserting and updating. Should not include Schema
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.InsertFormat">
            <summary>
            Format for a procedure that handles inserting a new record. Should not include Schema
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.UpdateFormat">
            <summary>
            Format for a procedure that handles updating existing a single record. Should not include Schema
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.DeleteFormat">
            <summary>
            Format for a procedure that handles deleting a single record. Should not include Schema
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.SelectRowFormat">
            <summary>
            Format for a procedure that handles selecting a single row. Should not include Schema
            </summary>
        </member>
        <member name="F:SEIDR.DataBase.DatabaseManager.SelectListFormat">
            <summary>
            Format for a procedure that handles selecting a list of rows. Should not include Schema
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.Execute(SEIDR.DataBase.DatabaseManagerHelperModel,System.Boolean)">
            <summary>
            Executes a SQL Command based on the ConnectionProcedureCallModel. 
            <para>If there's a transaction and <paramref name="CommitSuccess"/> is true, will commit the transaction on the model.</para>
            </summary>
            <param name="i"></param>
            <param name="CommitSuccess">If command is successful, commit the transaction on the model. If the model doesn't have a transaction, does nothing</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.ExecuteNonQuery(SEIDR.DataBase.DatabaseManagerHelperModel,System.Boolean)">
            <summary>
            Executes a SQL Command based on the ConnectionProcedureCallModel, with no result set.
            <para>If there's a transaction and <paramref name="CommitSuccess"/> is true, will commit the transaction on the model.</para>
            </summary>
            <param name="i"></param>
            <param name="CommitSuccess">If command is successful, commit the transaction from the model. If the model doesn't have a transaction, does nothing</param>
            <returns>Affected RowCount</returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.ExecuteNonQuery(System.String,System.Int32@,System.Object,System.Nullable{System.Boolean})">
            <summary>
            Executes the fully Qualified procedure.
            </summary>
            <param name="QualifiedProcedureName">Procedure name. If not actually fully qualified, use the default schema.</param>
            <param name="mapObj"></param>
            <param name="RetryDeadlock">Priority for determining whether to retry on deadlock</param>
            <returns>RowCount from ExecuteNonQuery</returns>
        </member>
        <member name="P:SEIDR.DataBase.DatabaseManager.RethrowException">
            <summary>
            Rethrows exceptions from execution. Set to false if dealing with procedures where you don't care about catching the exception yourself.
            </summary>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.ExecuteTextNonQuery(System.String,System.Nullable{System.Boolean})">
            <summary>
            Executes the command text as a non query.
            </summary>
            <param name="CommandText"></param>
            <param name="RetryDeadlock">If a value is provided, determines whether to retry on a deadlock.
            <para>If no value is provided, will use the DatabaseManager's value, or the default for HelperModels</para></param>
            <returns>Affected RowCount from Executing non query</returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.ExecuteText(System.String,System.Nullable{System.Boolean})">
            <summary>
            Executes the command text as a query.
            </summary>
            <param name="CommandText"></param>
            <param name="RetryDeadlock">If a value is provided, determines whether to retry on a deadlock.
            <para>If no value is provided, will use the DatabaseManager's value, or the default for HelperModels</para></param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.ExecuteText(SEIDR.DataBase.DatabaseManagerHelperModel,System.String,System.Boolean)">
            <summary>
            Executes the command text using settings/connection information from the Helper model
            </summary>
            <param name="i"></param>
            <param name="CommandText"></param>
            <param name="Commit"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.SelectSingle``1(SEIDR.DataBase.DatabaseManagerHelperModel,System.Boolean)">
            <summary>
            Selects a single record
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="i">Contain information for calling a procedure</param>
            <param name="RequireSingleResult">If true, will return null when the the procedure returns more than one result</param>
            <returns></returns>        
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.Update``1(``0,System.String,System.String,System.String[])">
            <summary>
            Calls the update procedure (name found using Schema attached to the UpdateFormat)
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="paramObj">Object with properties corresponding to the parameters used for updating a Database Object</param>
            <param name="Schema">Allow overriding the Manager's main schema</param>
            <param name="ignore">Ignore properties from object - if exists as a parameter, will try to use default parameter value</param>
        </member>
        <member name="M:SEIDR.DataBase.DatabaseManager.Insert``1(``0,System.String,System.String,System.String[])">
            <summary>
            Insert procedure - found by using the type name, formatted using the InsertFormat variable
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="paramObj"></param>
            <param name="suffix">Suffix to tack onto the end of the procedure name (E.g. '_Register' for RT=Batch to get usp_Batch_i_Register)</param>
            <param name="Schema"></param>
            <param name="ignore"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:SEIDR.DataBase.DatabaseManager.SelectWithKey(System.String,System.Object,System.String,System.Int32,System.Int32)" -->
        <member name="M:SEIDR.DataBase.DatabaseManager.SelectRowWithKey(System.String,System.Object,System.String)">
            <summary>
            Gets the first row from selecting by the Key, or null if there are no rows
            </summary>
            <param name="Key"></param>
            <param name="value"></param>
            <param name="TableOrView"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.DataBase.Schema.Schema">
            <summary>
            Helper class for DB Conversions
            </summary>
        </member>
        <member name="T:SEIDR.DateFormatter">
            <summary>
            A class to sugarcoat converting a consistent column to a DateTime. <para>Expected to be useful when you're not sure if a file will keep the same date format,
            if the date format changes depending on the column with the file, or if the c# code is expected to be reused for multiple, different data sources.</para>
            </summary>
            <remarks>It's technically possible for a junk column to be converted to a date. 
            <para>Ex: After finding the format for Col A to be mm-dd-yyyy, the string "ash04ketchum142014" should convert to 4/14/2014.</para>
            <para>Also to note, null and invisible characters should not impact date transformation AS LONG AS the *ENTIRE* date string can be read.</para>    
            </remarks>
        </member>
        <member name="F:SEIDR.DateFormatter.checkSanity">
            <summary>
            Set to true to prevent successful conversion of outstanding dates when calling ParseString. Default: False. 
            <para>E.g. 3/24/1825 would have a valid datetime out, but would return false instead of true.</para>
            </summary>
            <remarks>
            The requirements for failing sanity check are that it would be at least 100 years back from runtime, or at least 150 years into the future from runtime.
            <para>It's false by default since the usefulness of this really depends on what you're doing.</para>
            </remarks>
        </member>
        <member name="P:SEIDR.DateFormatter.size">
            <summary>
            Return the number of columns contained in the dateformatter. Columns and the number of columns cannot be changed without recreating the dateformatter. 
            <para>Columns CAN be renamed using the indexer and their index though.</para><para> E.g., df["pat"] -> 0. df[0] = "pie" -> . df["pat"] -> -1. df["pie"] -> 0</para>
            </summary>
        </member>
        <member name="M:SEIDR.DateFormatter.#ctor(System.Int32)">
            <summary>
            Creates a new date formatter.
            </summary>
            <param name="size">This should be the number of date columns you're expecting to exist.</param>
        </member>
        <member name="M:SEIDR.DateFormatter.#ctor(System.String[])">
             <summary>
             Create a new dateformatter using an array of column names.
             </summary>
            <param name="names">(Params) String array containing ALL names of columns expected to be dates. 
            Can be passed as just a number of string arguments if you don't have a lot of them</param>
        </member>
        <member name="P:SEIDR.DateFormatter.Item(System.String)">
            <summary>
            Returns the column index within the dateformatter of the given column's name. Not case sensitive
            </summary>
            <param name="column">Column you want the index of.</param>
            <returns>integer index of the column</returns>
        </member>
        <member name="P:SEIDR.DateFormatter.Item(System.Int32)">
            <summary>
            Get: Return the name of the column at that index. Set: Change the name of a column using it's index.
            </summary>
            <param name="column">Index</param>
            <returns>Empty string if no name has been set, else the name associated with a column</returns>
        </member>
        <member name="M:SEIDR.DateFormatter.getFormat(System.String)">
            <summary>
            Attempts to return the format for the given column. If unable to find the column using the given name, "Column not found" is returned instead.
            </summary>
            <param name="columnName">Name of the column</param>
            <returns>The format for the column to use when parsing the format.</returns>
        </member>
        <member name="M:SEIDR.DateFormatter.getFormat(System.Int32)">
            <summary>
            Attempts to return the format for the given column index. If unable to find the column using the given name, "Column not found" is returned instead.
            </summary>
            <param name="column">Index of the column in the dateFormatter. Can be obtained using an indexer if you're not sure.</param>
            <returns>Format for the column to use when parsing the format</returns>
        </member>
        <member name="M:SEIDR.DateFormatter.ParseFormat(System.String,System.Int32)">
            <summary>
            Takes a string and attempts to find the format to use in ParseString
            </summary>
            <param name="original">String to parse format from</param>
            <param name="column">Column the string is in.</param>
            <returns>True if we are able to parse a date from this string. False otherwise</returns>
        </member>
        <member name="M:SEIDR.DateFormatter.ParseString(System.String,System.String,System.DateTime@)">
            <summary>
            Calls on ParseString(int column, string value, out DateTime result) after finding the index of the column Name
            </summary>
            <param name="columnName">Name of column</param>
            <param name="value">Value to parse</param>
            <param name="result">Value converted to a DateTime</param>
            <returns>True if conversion to date succeeded.</returns>
        </member>
        <member name="M:SEIDR.DateFormatter.ParseString(System.Int32,System.String,System.DateTime@)">
            <summary>
            Attempts to parse the passed value using the given column's format.
            </summary>
            <param name="column">Index of column in dateformatter</param>
            <param name="value">Value to parse</param>
            <param name="result">Value converted to a DateTime</param>
            <returns>True if conversion to date succeeded. 
            <para>If CheckSanity is true, then failing the sanity check will cause this to return false even if the conversion to date succeeded</para>         
            </returns>
        </member>
        <member name="M:SEIDR.DateFormatter.ParseOnce(System.String,System.DateTime@,System.Boolean)">
            <summary>
            Creates a local dateformatter to run a single check on the date and then be deleted via leaving scope.
            </summary>
            <param name="value">String we want to parse</param>
            <param name="result">Output date</param>
            <param name="SanityCheck">If true, includes Sanity check</param>
            <returns>True if the result is a valid datetime</returns>
        </member>
        <member name="M:SEIDR.DateFormatter.ParseOnceS(System.String,System.DateTime@)">
            <summary>
            Same as the static ParseOnce method, but has Sanity Checking turned on
            </summary>
            <param name="value"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.ColumnDateFormatter">
            <summary>
            A class to sugarcoat converting a consistent column to a DateTime. <para>Expected to be useful when you're not sure if a file will keep the same date format,
            if the date format changes depending on the column with the file, or if the c# code is expected to be reused for multiple, different data sources.</para>
            </summary>
            <remarks>It's technically possible for a junk column to be converted to a date. 
            <para>Ex: After finding the format for Col A to be mm-dd-yyyy, the string "ash04ketchum142014" should convert to 4/14/2014.</para>
            <para>Also to note, null and invisible characters should not impact date transformation AS LONG AS the *ENTIRE* date string can be read.</para>    
            </remarks>
        </member>
        <member name="F:SEIDR.Doc.ColumnDateFormatter.checkSanity">
            <summary>
            Set to true to prevent successful conversion of outstanding dates when calling ParseString. Default: False. 
            <para>E.g. 3/24/1825 would have a valid datetime out, but would return false instead of true.</para>
            </summary>
            <remarks>
            The requirements for failing sanity check are that it would be at least 100 years back from runtime, or at least 150 years into the future from runtime.
            <para>It's false by default since the usefulness of this really depends on what you're doing.</para>
            </remarks>
        </member>
        <member name="P:SEIDR.Doc.ColumnDateFormatter.size">
            <summary>
            Return the number of columns contained in the ColumnDateFormatter. Columns and the number of columns cannot be changed without recreating the ColumnDateFormatter. 
            <para>Columns CAN be renamed using the indexer and their index though.</para><para> E.g., df["pat"] -> 0. df[0] = "pie" -> . df["pat"] -> -1. df["pie"] -> 0</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.ColumnDateFormatter.#ctor(System.Int32)">
            <summary>
            Creates a new date formatter.
            </summary>
            <param name="size">This should be the number of date columns you're expecting to exist.</param>
        </member>
        <member name="M:SEIDR.Doc.ColumnDateFormatter.#ctor(System.String[])">
             <summary>
             Create a new ColumnDateFormatter using an array of column names.
             </summary>
            <param name="names">(Params) String array containing ALL names of columns expected to be dates. 
            Can be passed as just a number of string arguments if you don't have a lot of them</param>
        </member>
        <member name="P:SEIDR.Doc.ColumnDateFormatter.Item(System.String)">
            <summary>
            Returns the column index within the ColumnDateFormatter of the given column's name. Not case sensitive
            </summary>
            <param name="column">Column you want the index of.</param>
            <returns>integer index of the column</returns>
        </member>
        <member name="P:SEIDR.Doc.ColumnDateFormatter.Item(System.Int32)">
            <summary>
            Get: Return the name of the column at that index. Set: Change the name of a column using it's index.
            </summary>
            <param name="column">Index</param>
            <returns>Empty string if no name has been set, else the name associated with a column</returns>
        </member>
        <member name="M:SEIDR.Doc.ColumnDateFormatter.getFormat(System.String)">
            <summary>
            Attempts to return the format for the given column. If unable to find the column using the given name, "Column not found" is returned instead.
            </summary>
            <param name="columnName">Name of the column</param>
            <returns>The format for the column to use when parsing the format.</returns>
        </member>
        <member name="M:SEIDR.Doc.ColumnDateFormatter.getFormat(System.Int32)">
            <summary>
            Attempts to return the format for the given column index. If unable to find the column using the given name, "Column not found" is returned instead.
            </summary>
            <param name="column">Index of the column in the ColumnDateFormatter. Can be obtained using an indexer if you're not sure.</param>
            <returns>Format for the column to use when parsing the format</returns>
        </member>
        <member name="M:SEIDR.Doc.ColumnDateFormatter.ParseFormat(System.String,System.Int32)">
            <summary>
            Takes a string and attempts to find the format to use in ParseString
            </summary>
            <param name="original">String to parse format from</param>
            <param name="column">Column the string is in.</param>
            <returns>True if we are able to parse a date from this string. False otherwise</returns>
        </member>
        <member name="M:SEIDR.Doc.ColumnDateFormatter.ParseString(System.String,System.String,System.DateTime@)">
            <summary>
            Calls on ParseString(int column, string value, out DateTime result) after finding the index of the column Name
            </summary>
            <param name="columnName">Name of column</param>
            <param name="value">Value to parse</param>
            <param name="result">Value converted to a DateTime</param>
            <returns>True if conversion to date succeeded.</returns>
        </member>
        <member name="M:SEIDR.Doc.ColumnDateFormatter.ParseString(System.Int32,System.String,System.DateTime@)">
            <summary>
            Attempts to parse the passed value using the given column's format.
            </summary>
            <param name="column">Index of column in ColumnDateFormatter</param>
            <param name="value">Value to parse</param>
            <param name="result">Value converted to a DateTime</param>
            <returns>True if conversion to date succeeded. 
            <para>If CheckSanity is true, then failing the sanity check will cause this to return false even if the conversion to date succeeded</para>         
            </returns>
        </member>
        <member name="M:SEIDR.Doc.ColumnDateFormatter.ParseOnce(System.String,System.DateTime@,System.Boolean)">
            <summary>
            Creates a local ColumnDateFormatter to run a single check on the date and then be deleted via leaving scope.
            </summary>
            <param name="value">String we want to parse</param>
            <param name="result">Output date</param>
            <param name="SanityCheck">If true, includes Sanity check</param>
            <returns>True if the result is a valid datetime</returns>
        </member>
        <member name="M:SEIDR.Doc.Compression.PLZ.CalculatePI(System.Int32)">
            <summary>
            Taken from <see ref="stackoverflow.com/questions/11677369/how-to-calculate-pi-to-n-number-of-places-in-c-sharp-using-loops "/>
            </summary>
            <param name="digits"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.DelimitedDocumentReader">
            <summary>
            Wrapper class for reading delimited files.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentReader.EMPTY">
            <summary>
            Returns a delimited record with no content, but set up to match the format from this document... 
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DelimitedDocumentReader.ALIAS">
            <summary>
            Alias for the document, can be used for determining source of a delimited record. Defaults to file name without extension
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.GetHeader(System.Boolean)">
            <summary>
            Returns the header values delimited by the document's delimiter
            </summary>
            <param name="useDefaultHeader"></param>        
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.Reset">
            <summary>
            Resets the document to the start of the file. Does not change other settings like added headers.
            <para>Note that it will start off at the same place as it did originally.</para>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentReader.CurrentPage">
            <summary>
            get the records on the current page
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.GetNextPage">
            <summary>
            Increment the page and return its records
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.GetPage(System.Int32)">
            <summary>
            Get a 'page' of delimited records
            </summary>
            <param name="page">Zero based page number. If the page number goes out of range, returns null</param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentReader.Page">
            <summary>
            Gets the current "page" of the document
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.GetHeader(System.Char,System.Boolean)">
            <summary>
            Gets the header joined by a new delimiter instead of the original
            </summary>
            <param name="newDelimiter"></param>
            <param name="useDefaultHeader"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.GetHeader">
            <summary>
            Returns the headers as an an array of column names
            </summary>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentReader.SkippedLines">
            <summary>
            Returns the lines skipped by the reader based on the line to skip parameter
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentReader.DefaultPageSize">
            <summary>
            Default value for new readers
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentReader.PageSize">
            <summary>
            Modifies the number of characters read at a time when creating records and determines the maximum number of characters per page
            <para>Minimum size of 34,000</para>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentReader.pageRecordCount">
            <summary>
            Number of records on th current page
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentReader.minRecord">
            <summary>
            Minimum record number on the current page
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentReader.maxRecord">
            <summary>
            Maximum record number on the current page
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.AddHeader(System.String)">
            <summary>
            Adds a header to the document. Used for access in the Delimited record/adding extra columns if the record is being used elsewhere.
            </summary>
            <param name="Header"></param>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentReader.FilePath">
            <summary>
            Returns the path used for the file being read.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.ResetHeader">
            <summary>
            Resets the header for Delimited records to match what was originally set
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.#ctor(System.String,System.Int32,System.String[])">
            <summary>
            Creates a simple instance fo a delimited document to iterate through line by line, with the column delimiter guessed
            </summary>
            <param name="FilePath"></param>
            <param name="linesToSkip"></param>
            <param name="Header">Optional, the headers for the document. If null, will use the first line</param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.#ctor(System.String,System.Nullable{System.Char},System.Int32)">
            <summary>
            Creates an instance of a delimited Document to iterate through, line by line.
            <para>Assumes that there is a header at the first line after finish skipping</para>
            </summary>
            <param name="FilePath"></param>
            <param name="Delimiter">If null, will treat as a single column</param>        
            <param name="linesToSkip"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.#ctor(System.String,System.Nullable{System.Char},System.String[],System.Int32)">
            <summary>
            Creates an instance of a Delimited Document to iterate through line by line
            </summary>
            <param name="Filepath"></param>
            <param name="Delimiter"></param>
            <param name="Header"></param>
            <param name="linesToSkip"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.GetEnumerator">
            <summary>
            Loops through the document's content and provides DelimitedRecords
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.Dispose">
            <summary>
            Disposes the underlying file reader
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentReader.Finalize">
            <summary>
            
            </summary>
        </member>
        <member name="T:SEIDR.Doc.ReadonlyLines">
            <summary>
            For maintaining a readonly array of strings
            </summary>
        </member>
        <member name="P:SEIDR.Doc.ReadonlyLines.Item(System.Int32)">
            <summary>
            Gets the skipped line from the specified index
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.ReadonlyLines.#ctor(System.String[])">
            <summary>
            Constructor
            </summary>
            <param name="Lines"></param>
        </member>
        <member name="T:SEIDR.Doc.DelimitedDocumentWriter">
            <summary>
            For adding delimited records to a file. 
            <para>Can be used in conjunction with DelimitedDocumentReader to filter or combine files</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.#ctor(System.String,System.Char,System.Boolean,System.String[])">
            <summary>
            Creates an instance of DelimiteddocumentWriter for adding records to the FilePath
            </summary>
            <param name="FilePath"></param>
            <param name="AppendIfExists">If true, will keep the existing file and just append files. Otherwise will reset the file if it exists already</param>
            <param name="delimiter">The delimiter for records that get added</param>
            <param name="HeaderList"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.#ctor(System.String,System.Char,System.String[])">
            <summary>
            Creates an instance of DelimiteddocumentWriter for adding records to the FilePath.
            <para>Restarts the file if it already exists</para>
            </summary>
            <param name="filepath"></param>
            <param name="Delimiter"></param>
            <param name="Headers"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.#ctor(System.String,System.Boolean,System.String[])">
            <summary>
            Creates an instance of DelimiteddocumentWriter for adding records to the FilePath with the default delimiter
            </summary>
            <param name="Filepath"></param>
            <param name="AppendIfExists">If true, will keep the existing file and just append files. Otherwise will reset the file if it exists already</param>        
            <param name="HeaderList"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.#ctor(System.String,System.String[])">
            <summary>
            Creates an instance of DelimiteddocumentWriter for adding records to the FilePath with the default delimiter
            <para>Resets the file if it exists already.</para>
            </summary>
            <param name="FilePath"></param>        
            <param name="HeaderList"></param>
        </member>
        <member name="F:SEIDR.Doc.DelimitedDocumentWriter.MaxBatchSize">
            <summary>
            Batch size - when the number of records added exceeds this value, they will be added to the file.
            <para>Default value is 50000</para>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DelimitedDocumentWriter.Delimiter">
            <summary>
            Delimiter for records when writing
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DelimitedDocumentWriter.DefaultDelimiter">
            <summary>
            The default delimiter for new DocumentWriters.
            Default value is set to '|'
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.AddRecordMerge(SEIDR.Doc.DelimitedRecord,SEIDR.Doc.DelimitedRecord)">
            <summary>
            Merges the two DelimitedRecords and adds them to the documentWriter
            </summary>
            <param name="record1"></param>
            <param name="record2"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.AddRecordMerge(SEIDR.Doc.DelimitedRecord[])">
            <summary>
            Merges multiple delimited records together and adds them to the document output
            </summary>
            <param name="toMerge"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.AddRecord(SEIDR.Doc.DelimitedRecord)">
            <summary>
            Adds the delimited record to the DocumentWriter
            </summary>
            <param name="record"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.AddRecordBatch(SEIDR.Doc.DelimitedRecord[])">
            <summary>
            Add multiple delimited records at one time
            </summary>
            <param name="recordBatch"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.Dispose">
            <summary>
            Ensures that all records that have been added to the documentWriter get added to the actual file.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedDocumentWriter.HasHeader">
            <summary>
            If set to true, the document will be created with the header created
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.Flush">
            <summary>
            Adds all of the records that have been added to the file.
            <para>Also clears the records from the internal list.</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedDocumentWriter.Reset(System.Nullable{System.Boolean})">
            <summary>
            Restarts the file
            </summary>
            <param name="IncludeHeader"></param>
        </member>
        <member name="T:SEIDR.Doc.DelimitedFileIndexInfo">
            <summary>
            Inforamtion about a Seidr Index
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DelimitedFileIndexInfo.FILE_EXTENSION">
            <summary>
            Extension for index files used by DelimitedIndex class
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedFileIndexInfo.IndexFile">
            <summary>
            Path storing the location of the index file
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedFileIndexInfo.FilePath">
            <summary>
            Path to the file the index is built for
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedFileIndexInfo.FileDelimiter">
            <summary>
            Column delimiter for the file being indexed
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedFileIndexInfo.Columns">
            <summary>
            Columns stored by the index in order
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedFileIndexInfo.#ctor(System.String,System.String,System.Nullable{System.Char},System.String[])">
            <summary>
            Constructor with delimiter specified
            </summary>
            <param name="RawFilePath"></param>
            <param name="IndexFilePath"></param>
            <param name="Delimiter"></param>
            <param name="ColumnList"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedFileIndexInfo.#ctor(System.String,System.String,System.String[])">
            <summary>
            Creates an index info class without the delimiter specified
            </summary>
            <param name="RawFilePath"></param>
            <param name="IndexFilePath"></param>
            <param name="ColumnList"></param>
        </member>
        <member name="T:SEIDR.Doc.DelimitedIndex">
            <summary>
            Class representing an index for a Delimited Document. Takes an indexFile for a constructor
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DelimitedIndex.Header">
            <summary>
            For reading from the actual index file
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DelimitedIndex._IndexInfo">
            <summary>
            Info describing the file being indexed. Meta data for the index file basically
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedIndex.IndexFile">
            <summary>
            Returns the name of the file being used for the index. Note that it should always have the extension ".sidx",
            unless the file was created outside of this class
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedIndex.SetFilter(System.Collections.Generic.Dictionary{System.String,System.String})">
            <summary>
            Sets up the filter on the index so that you can iterate on records that meet the conditions.        
            </summary>   
            <remarks>If the filter can be parsed as a double, it will look for an exact match -  otherwise just that it's contained
            <para>If the value is null, it will check for empty or white space values.
            </para></remarks>        
            <param name="filters">Column:Value pair to use for filtering the values stored in the index</param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedIndex.#ctor(SEIDR.Doc.DelimitedFileIndexInfo)">
            <summary>
            Sets up a delimited index based on the IndexInfo for setup
            </summary>
            <param name="setupInfo"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedIndex.#ctor(System.String)">
            <summary>
            Creates a delimited Index object using the index's actual file
            </summary>
            <param name="IndexFile"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedIndex.Dispose">
            <summary>
            Disposer
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedIndex.GetEnumerator">
            <summary>
            Iterate through the indexed records, or through everything if it has not had a filter set
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedIndex.CreateIndex">
            <summary>
            Checks if the index already exists - if it exists but is older than the actual file's last update, a new index will be created.
            <para>If a new index is created, the index will be reset, but otherwise it will stay at the same position of the index file.</para>
            <para>Will need to re-set the filter if a new index is created</para>
            </summary>
            <returns>False if the index did not need to be created - true if a new index was created</returns>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.Aggregation.Counter">
            <summary>
            Number of non null records matched to this aggregation
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.Condition.#ctor(SEIDR.Doc.DocQuery.TransformedColumnMetaData,SEIDR.Doc.DocQuery.TransformedColumnMetaData,SEIDR.Doc.DocQuery.ConditionType)">
            <summary>
            Condition information for checking if columns match a condition for a passed record
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <param name="join">Determines logic to be used in matches. <para>
            Note: For IS NULL and IS NOT NULL, <paramref name="right"/> will be ignored.</para>
            <para>Also, it's probably better to use the static GetNULLCondition methodthen.</para></param>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.Condition.Matches(SEIDR.Doc.IRecord)">
            <summary>
            Works with a record that has already had all the content merged together into one delimited record by <see cref="M:SEIDR.Doc.DelimitedRecord.Merge(SEIDR.Doc.DelimitedRecord,SEIDR.Doc.DelimitedRecord)"/>
            </summary>
            <param name="merged"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.ConditionNode.ConditionCount">
            <summary>
            Count of nodes with populated conditions
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.ConditionNode.AddSiblingCondition(SEIDR.Doc.DocQuery.Condition)">
            <summary>
            Adds the condition as a sibling ('OR' condition)
            </summary>
            <param name="OR"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.ConditionNode.AddChainNodes(SEIDR.Doc.DocQuery.ConditionNode[])">
            <summary>
            Note that this is adding ConditionNodes - i.e., they can already have their own children populated
            </summary>
            <param name="toAdd"></param>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.ConditionNode.AddFlatChainConditions(SEIDR.Doc.DocQuery.Condition[])">
            <summary>
            Add a list of 'OR' grouped chains to the bottom of each child recursively
            </summary>
            <param name="toAdd"></param>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.ConditionNode.AddNode(SEIDR.Doc.DocQuery.ConditionNode)">
            <summary>
            If the new node would be a constant (false), it is ignored, and the current instance is returned instead
            </summary>
            <param name="n"></param>
            <returns></returns>
        </member>
        <member name="F:SEIDR.Doc.DocQuery.ConditionTree.LeftHashColumns">
            <summary>
            Columns for the left side. Should be populated by optimization
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocQuery.DelimitedJoin.unmatched">
            <summary>
            Use for tracking positions in file that need to be returned in a right or outer join
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedJoin.GetUnmatched">
            <summary>
            For right/outer joins, returns the records that had no match, with the columns to the left prepended as empty.
            <para>Ends early once there are no more unmatched records</para>
            </summary>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.DocQuery.DelimitedQuery">
            <summary>
            Experiment for querying (select, inner join, left join, where clause filter) records from a delimited file.    
            <para>Syntax:</para><br />
            <para>ALIAS ______:(filepath)</para>
            <para>...</para>
            <para>SELECT [__ALIAS__].[ColumnName], [__ALIAS__].[ColumnName], ...</para>
            <para>FROM [__ALIAS__]</para>
            <para>{JOIN|LEFT JOIN} [__ALIAS__] ON [__ALIAS__].[ColumnName] {==|&lt;=|&gt;|&lt;|&gt;=|!=} {[__ALIAS__].[ColumnName] | __LITERAL__} { AND | OR __remaining conditions__ }</para>
            <para>{WHERE [__ALIAS__].[ColumnName] { IS {NOT} NULL | {{==|&lt;=|&gt;|&lt;|&gt;=|!=} {[__ALIAS__].[ColumnName] | __LITERAL__}  } } {AND | OR __Remainin filters__}(</para>
            <para>Note: ands are grouped before Or, unless in parenthesis..</para>
            <br /> On Data types - to specify non varchar, do the following: {DATE|MONEY|NUM}([__ALIAS__].[ColumnName])
            <br />On Literals- specify date with {DATE|MONEY|NUM|}( __Literal___)
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedQuery.Execute(System.String,System.Char)">
            <summary>
            Execute query, writes output to destination file.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedQuery.Execute">
            <summary>
            Safe call to the getEnumerator (implicit foreach on instance)
            <para>If Query is not in valid state, skips any records</para>
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedQuery.GetEnumerator">
            <summary>
            Executes query, yields Delimited records instead of creating an output file
            </summary>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.DelimitedQuery.IsValid">
            <summary>
            Check if the query is valid before running.
            <para>An invalid operation exception will be thrown if this returns false when executing.</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedQuery.Parse(System.String)">
            <summary>
            Parse a script to create a DelimitedQuery to run
            </summary>
            <param name="QueryContent"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedQuery.Optimize">
            <summary>TODO:
            Removes extra join conditions, moves filters to earlier joins if possible, mark conditions as hash joins where possible
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DocQuery.DelimitedRecordHashTable">
            <summary>
            For eventually performing delimited record hash joins
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.#ctor(System.String[])">
            <summary>
            Creates an object for storing delimited records and accessing them based on their partial hash.
            </summary>
            <param name="Columns"></param>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.#ctor(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Creates an object for storing delimited records using an IEnumerable of strings.
            </summary>
            <param name="Columns"></param>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.Item(SEIDR.Doc.DelimitedRecord)">
            <summary>
            Returns an enumerable of records that match on the hash
            </summary>
            <param name="record"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.CheckHash(SEIDR.Doc.DelimitedRecord)">
            <summary>
            Calculates the hash for this record that would be used by this hash table.
            <para>Note that the table only uses records that have a non null value</para>
            </summary>
            <param name="record"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.Item(System.UInt64)">
            <summary>
            Returns an enumerable of records that match on the hash
            </summary>
            <param name="hash"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.GetMatchingRecords(SEIDR.Doc.DelimitedRecord)">
            <summary>
            Gets an enumerable of records that have the same hash
            </summary>
            <param name="record"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.Item(System.UInt64,System.Int32)">
            <summary>
            Gets the delimited record at the specified index
            </summary>
            <param name="hashValue"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.CheckCount(System.UInt64)">
            <summary>
            Gets count of records associated with the provided hash
            </summary>
            <param name="Value"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.CheckCount(SEIDR.Doc.DelimitedRecord)">
            <summary>
            Gets the number of records with the same hash as the delimited record
            </summary>
            <param name="Value"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.Add(SEIDR.Doc.DelimitedRecord)">
            <summary>
            Adds the delimited record to the underlying data structure, if the hash has a value.
            </summary>
            <param name="newRecord"></param>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.Add(SEIDR.Doc.DelimitedRecord[])">
            <summary>
            Adds all records to the underlying data structure
            </summary>
            <param name="newRecordList"></param>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.Add(System.Collections.Generic.IEnumerable{SEIDR.Doc.DelimitedRecord})">
            <summary>
            Adds all records to the underlying data structure
            </summary>
            <param name="newRecordList"></param>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.Clear">
            <summary>
            Completely clears the underlying data structure
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.Clear(System.UInt64)">
            <summary>
            Removes all records associated with the hash
            </summary>
            <param name="hash"></param>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DelimitedRecordHashTable.ClearSameHash(SEIDR.Doc.DelimitedRecord)">
            <summary>
            Removes all records with the same hash as the record
            </summary>
            <param name="record"></param>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.DocQuerySettings.ExceptionOnParseFailure">
            <summary>
            If true, will throw an exception when failing to parse a non varchar.
            <para>Otherwise, will treat as null.</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.DocQuerySettings.SetExceptionOnParseFailure(System.Boolean)">
            <summary>
            Sets value for ExceptionOnParseFailure
            </summary>
            <param name="exception"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.HashJoin.DoJoin(SEIDR.Doc.DelimitedRecord)">
            <summary>
            Returns all matches for current record from the left
            </summary>
            <param name="left"></param>        
            <returns></returns>
        </member>
        <member name="F:SEIDR.Doc.DocQuery.Predicates.ConditionParser.KeyWords">
            <summary>
            Note: Should be stopped before a where
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.Predicates.ConditionParser.ParseExpression">
            <summary>
            Delegate for parsing expressions (functionality set in <see cref="P:SEIDR.Doc.DocQuery.Predicates.LeafCondition.ContentInformation"/>).
            <para>Will be the content on either side of comparison operators (e.g., '&lt;&gt;', '=', '&lt;=', '&gt;', etc)</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.Predicates.ConditionParser.Parse(System.String)">
            <summary>
            
            </summary>
            <param name="content">If a join, should be the portion between ON but not including and either the next join or "WHERE", ";", "SELECT", "UNION"<para>
            If a where, should be the portion between but not including the next ";", "SELECT", "UNION" </para></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.DocQuery.Predicates.IsNullCondition">
            <summary>
            Leaf condition, check if a column (or constant from meta data) is null or not null
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DocQuery.Predicates.JoinCondition">
            <summary>
            Join condition- joins delimited record columns. left and right should be ignroed
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DocQuery.Predicates.NotCondition">
            <summary>
            Single child condition. 
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.Predicates.RootCondition.Simple">
            <summary>
            Checks if the child is a leaf condition - if so, it should be safe to merge the condition with other conditions, if the aliases are available.        
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.Predicates.RootCondition.HashConditionType">
            <summary>
            Returns the condition type for the hash condition - equal or not equal
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.Predicates.RootCondition.Evaluate(SEIDR.Doc.DocRecord)">
            <summary>
            Checks if the record passes Conditions
            </summary>
            <param name="record"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.Predicates.RootCondition.MergeWithRoot(SEIDR.Doc.DocQuery.Predicates.RootCondition)">
            <summary>
            Attempts to merge RootCondition b into this root Condition
            </summary>
            <param name="b"></param>
            <returns>True if b was successfully merged into this RootCondition</returns>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.TransformedColumn.ValidContent">
            <summary>
            Check if the column is valid for comparisons.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.TransformedColumn.IsNull">
            <summary>
            Check if the column is null for the content.
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DocQuery.TransformedMoney">
            <summary>
            Decimal content
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DocQuery.TransformedNum">
            <summary>
            int 64 content
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.TransformedColumnMetaDataCollection.Count">
            <summary>
            Number of meta data items in the collection
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.TransformedColumnMetaDataCollection.Item(System.String,System.String)">
            <summary>
            Gets the Meta Data for the specified column, or null if not exists
            </summary>
            <param name="alias"></param>        
            <param name="Column"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocQuery.TransformedColumnMetaDataCollection.Item(System.Int32)">
            <summary>
            Gets the column meta data based on Ordinal position.
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.TransformedColumnMetaDataCollection.AddMetaData(SEIDR.Doc.DocQuery.TransformedColumnMetaData)">
            <summary>
            Adds the meta data to the collection, if the column isn't already in use.
            </summary>
            <param name="newMetaData"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.TransformedColumnMetaDataCollection.RemoveMetaData(System.String,System.String)">
            <summary>
            Removes any meta data for the column name
            </summary>
            <param name="oldMetaDataColumn"></param>
            <param name="OwnerAlias">Specifies the file owner for the column</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.TransformedColumnMetaDataCollection.UpdateMetaData(SEIDR.Doc.DocQuery.TransformedColumnMetaData)">
            <summary>
            Replaces any existing meta data for the parameter's Column with newMetaData
            </summary>
            <param name="newMetaData"></param>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.TransformedColumnMetaDataCollection.GetColumn(System.String,System.String,SEIDR.Doc.IRecord)">
            <summary>
            Gets a TransformedColumn for the specified column name using any meta data
            <para>for the column.</para>
            <para>If no meta data is found, it will be treated as null</para>
            </summary>
            <param name="alias">File aliasfrom querying</param>
            <param name="ColumnName"></param>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.DocQuery.TransformedColumnMetaData">
            <summary>
            Contains information about a column for usage in a Delimited Query's conditions and/or joining
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocQuery.TransformedColumnMetaData.ColumnName">
            <summary>
            Name of the column for use in a MetadataCollection
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocQuery.TransformedColumnMetaData.OwnerAlias">
            <summary>
            Alias of the document containing the column meta data..
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.TransformedColumnMetaData.Matches(SEIDR.Doc.DocRecordColumnInfo)">
            <summary>
            Return true if this is referencing the same content, based on the alias and and column name
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocQuery.TransformedColumnMetaData.op_Implicit(SEIDR.Doc.DocQuery.TransformedColumnMetaData)~SEIDR.Doc.DocRecordColumnInfo">
            <summary>
            Implicitly convert to Column info
            </summary>
            <param name="a"></param>
        </member>
        <member name="F:SEIDR.Doc.DocQuery.TransformedColumnMetaData.Type">
            <summary>
            Used for type validation before performing any comparisons. 
            Null is allowed by default
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocQuery.TransformedColumnMetaData.Transform">
            <summary>
            Transforms the content 
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DelimitedRecord">
            <summary>
            Contains individual lines from Delimited Document.
            <para>Read only except for being able to add extra columns to the end as a sort of tag.</para>
            <para>Can be used to write a record to a new file using the ToString() method.</para>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedRecord.FullRecordHash">
            <summary>
            Returns a ulong value of the record's ToString as a hash
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.GetPartialHash(System.String[])">
            <summary>
            Returns an unsigned long hash code using a rolling hash
            </summary>
            <param name="ColumnsToHash"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.GetPartialHash(System.Boolean,System.String[])">
            <summary>
            Returns an unsigned long hash code, using either a rolling hash or string's GetHashCode.
            If any of the column values are null or empty strings, will return null instead of a value
            </summary>
            <param name="RollingHash"></param>
            <param name="columnsToHash"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.GetPartialHash(System.Boolean,System.Boolean,SEIDR.Doc.DocRecordColumnInfo[])">
            <summary>
            Returns an unsigned long hash code, using either a rolling hash or string's GetHashCode.
            If any of the column values are null or empty strings, will return null instead of a value
            </summary>
            <param name="RollingHash"></param>
            <param name="ExcludeEmpty">If true, will treat empty strings as a null</param>
            <param name="columnsToHash"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DelimitedRecord.HeaderList">
            <summary>
            Returns a copy of the header information
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedRecord.Delimiter">
            <summary>
            Gets the delimiter associated with the record
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.ChangeDelimiter(System.Char)">
            <summary>
            Changes the delimiter, but only if the record already has a delimiter.
            </summary>
            <param name="newValue"></param>
            <returns>Returns true if the delimiter was changed, else false</returns>
        </member>
        <member name="P:SEIDR.Doc.DelimitedRecord.NullIfTruncated">
            <summary>
            If set to true, will return null instead of erroring when the line does not have enough records for the index even though
            <para>the header length indicates that it should have enough records.</para>
            <para>Used when accessing without headers</para>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DelimitedRecord.Item(System.Int32)">
            <summary>
            Gets the value of the record at the provided index. For use when Headers are not being used.
            </summary>
            <param name="index">0 based index to grab content from</param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DelimitedRecord.Item(System.String)">
            <summary>
            Gets the first value of the record for the provided column( any alias)
            </summary>
            <param name="Column"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DelimitedRecord.Item(System.String,System.String)">
            <summary>
            Gets the content owned by the specified column under the specified alias
            </summary>
            <param name="Alias"></param>
            <param name="ColumnName"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.GetValue``1(System.String,System.String,``0)">
            <summary>
            Gets the value specified by the column and converts it to T. Does not handle WhiteSpace
            </summary>
            <typeparam name="T">Must be a primitive type. See the System.TypeCode enumeration</typeparam>
            <param name="Alias">Owning alias. Null will search for the for the first column that matches by name</param>
            <param name="Column"></param>
            <param name="defaultVal">Default value to use if there's no content</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.GetValue``1(System.String,``0)">
            <summary>
            Gets the value specified for the first column that matches (regardless of alias) and converts to T.
            </summary>
            <typeparam name="T"></typeparam>
            <param name="Column"></param>
            <param name="defaultVal"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.GetValue``1(System.Int32)">
            <summary>
            Gets the value specified at the given index and converts it to T.
            </summary>
            <typeparam name="T">Must be a primitive type. See the System.TypeCode enumeration</typeparam>
            <param name="index">Numeric index of the data to grab</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.GetContent">
            <summary>
            Returns a new list copy of the internal content of this record.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.Merge(SEIDR.Doc.DelimitedRecord,SEIDR.Doc.DelimitedRecord)">
            <summary>
            Combines delimited records. Must be set up for using Headers
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.MergeEmpty(System.Collections.Generic.IList{SEIDR.Doc.DocRecordColumnInfo},SEIDR.Doc.DelimitedRecord)">
            <summary>
            Returns a new delimited record with the empty columns at the beginning
            </summary>
            <param name="columns"></param>
            <param name="record"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.GetSubset(SEIDR.Doc.DelimitedRecord,System.Collections.Generic.IList{SEIDR.Doc.DocRecordColumnInfo})">
            <summary>
            Gets a new delimited record containing a subset of the columns from the working record
            </summary>
            <param name="work"></param>
            <param name="columns"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.#ctor(System.String[],System.Nullable{System.Char})">
            <summary>
            Creates a delimited record but with no Header information.
            <para> Will not be able to access column data using column names</para>
            </summary>
            <param name="Content"></param>
            <param name="Delimited"></param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.#ctor(System.String[],System.String[],System.Int32,System.Nullable{System.Char},System.String)">
            <summary>
            Creates a new record
            </summary>
            <param name="Header"></param>
            <param name="Content"></param>
            /// <param name="contentExpectedLength">Expected number of columns to be in the passed content - should match the number of columns in the physical file when reading.</param>
            <param name="OwnerAlias">Alias of object owning the columns</param>
            <param name="Delimiter">Delimiter that split Content into an array</param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.#ctor(System.String[],System.String,System.Int32,System.Nullable{System.Char},System.String)">
            <summary>
            Creates a new delimited record using the delimiter provided to split the content string
            </summary>
            <param name="Header"></param>
            <param name="Content"></param>
            <param name="contentExpectedLength">Expected number of columns to be in the passed content - should match the number of columns in the physical file when reading.</param>
            <param name="Delimiter"></param>
            <param name="Alias">Owner alias</param>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.ConvertToType``1">
            <summary>
            Converts the record into a instance of type 'T'
            <para>Note: Fields may or may not work as expected with setting values.</para>
            <para>Note: Complex types like lists or arrays are not supported, only primitives. If you want more complex logic, you'll have to convert yourself</para>
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DelimitedRecord.ToString">
            <summary>
            Combines the content into a delimited string
            </summary>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocMetaData.FixedWidthMode">
            <summary>
            If true, Columns are fixed width and will use lengths. <para>Otherwise, will use the delimiter.</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.TrySetFixedWidthMode(System.Boolean)">
            <summary>
            Tries to set the doc to fixed width mode. Returns true if value is updated.
            </summary>
            <param name="useFixedWidth"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocMetaData.FileEncoding">
            <summary>
            File encoding
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.SetFileEncoding(System.Text.Encoding)">
            <summary>
            Sets the file encoding for reading and writing.
            </summary>
            <param name="fileEncoding"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocMetaData.PageSize">
            <summary>
            Max number of characters to have in a page when reading from a file
            <para>Will throw an exception if the page is too small to completely parse a line somewhere in the file</para>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocMetaData.minPageSize">
            <summary>
            Minimum page size (in characters)
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocMetaData.Columns">
            <summary>
            The columns from the file
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocMetaData.AccessMode">
            <summary>
            Access mode for file opening. Indicates whether the DocMetaData will be used for Doc reading or doc writing
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.SetFileAccess(System.IO.FileAccess)">
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocMetaData.Valid">
            <summary>
            Meta data can be used for reading or writing to a file.
            <para>Ensures that file path is valid if access mode includes read</para>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocMetaData.HasHeader">
            <summary>
            If true, first line of the file after skip lines should be the header
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocMetaData.Delimiter">
            <summary>
            Gets the delimiter from <see cref="P:SEIDR.Doc.DocMetaData.Columns"/>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocMetaData.EmptyIsNull">
            <summary>
            Treat empty records as null when getting values/hashes
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.SetHasHeader(System.Boolean)">
            <summary>
            Sets <see cref="P:SEIDR.Doc.DocMetaData.HasHeader"/>
            </summary>
            <param name="headerIncluded"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocMetaData.SkipLines">
            <summary>
            Number of lines to skip at the start of the file when reading. Does not include the header's line
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.SetLineEndDelimiter(System.String)">
            <summary>
            Sets the string that indicates end of records. Default is <see cref="P:System.Environment.NewLine"/>
            <para>If dealing with fixed width and records should be split only by length, set to null</para>
            </summary>
            <param name="endLine"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.AddDelimitedColumns(System.String[])">
            <summary>
            Adds basic columns to be delimited by <see cref="P:SEIDR.Doc.DocMetaData.Delimiter"/>.
            </summary>
            <param name="columnNames"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocMetaData.AddDetailedColumn(SEIDR.Doc.DocRecordColumnInfo[])">
            <summary>
            Adds one or more populated <see cref="T:SEIDR.Doc.DocRecordColumnInfo"/> instances to the Columns Collection
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocReader.ReConfigure">
            <summary>
            Reconfigures the Reader settings/paging information, using any changes to the DocMetaData that was provided
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocReader.#ctor(System.String,System.String,System.String,System.Nullable{System.Char})">
            <summary>
            Sets up a basic delimited reader, assuming the file has headers starting on the first line.
            </summary>
            <param name="alias"></param>
            <param name="FilePath"></param>
            <param name="LineEnd">The line ending. If null, will use <see cref="P:System.Environment.NewLine"/></param>
            <param name="Delimiter">Column delimiter. If null, will try to guess when parsing, based on the content of the first line found.</param>
        </member>
        <member name="P:SEIDR.Doc.DocReader.Item(System.Int32,System.Int32)">
            <summary>
            Attempts to grab a specific DocRecord off the specified page
            </summary>
            <param name="pageNumber"></param>
            <param name="pageLineNumber"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocReader.GetPage(System.Int32)">
            <summary>
            0 based page get
            </summary>
            <param name="pageNumber"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.DocRecord">
            <summary>
            Read/write class for use with DocQueries, DocReader, and DocWriter
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecord.FullRecordHash">
            <summary>
            Returns a ulong value of all columns
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.GetPartialHash(System.String[])">
            <summary>
            Returns an unsigned long hash code using a rolling hash
            </summary>
            <param name="ColumnsToHash"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.GetPartialHash(System.Boolean,System.String[])">
            <summary>
            Returns an unsigned long hash code, using either a rolling hash or string's GetHashCode.
            If any of the column values are null or empty strings, will return null instead of a value
            </summary>
            <param name="RollingHash"></param>
            <param name="columnsToHash"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.GetPartialHash(System.Boolean,System.Boolean,System.Collections.Generic.IList{SEIDR.Doc.DocRecordColumnInfo})">
            <summary>
            Returns an unsigned long hash code, using either a rolling hash or string's GetHashCode.
            <para>If any of the column values are null, will return null.</para>
            </summary>
            <param name="RollingHash"></param>
            <param name="includeNull">If true, will replace null with empty string.</param>
            <param name="ColumnsToHash"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.GetPartialHash(System.Boolean,System.Boolean,SEIDR.Doc.DocRecordColumnInfo[])">
            <summary>
            Returns an unsigned long hash code, using either a rolling hash or string's GetHashCode.
            If any of the column values are null or empty strings, will return null instead of a value
            </summary>
            <param name="RollingHash"></param>
            <param name="ExcludeEmpty">If true, will treat empty strings as a null</param>
            <param name="columnsToHash"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.Merge(System.String,SEIDR.Doc.DocRecord,SEIDR.Doc.DocRecord)">
            <summary>
            Merges the DocRecords and specifies the alias for the new Column Collection underlying.
            <para>The new alias will be used for any new columns added to the underlying collection</para>
            </summary>
            <param name="Alias"></param>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.HasColumn(System.String,System.String)">
            <summary>
            Checks if the record's column information contains the information being requested
            </summary>
            <param name="Alias"></param>
            <param name="ColumnName"></param>
            <returns></returns>
        </member>
        <member name="F:SEIDR.Doc.DocRecord.Columns">
            <summary>
            Used for determining records...
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.ToString">
            <summary>
            Overrides to string, combining the columns depending on the set up of the Column Collection it was created with
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.#ctor(SEIDR.Doc.DocRecordColumnCollection)">
            <summary>
            Sets up a very basic DocRecord
            </summary>
            <param name="owner"></param>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.#ctor(SEIDR.Doc.DocRecordColumnCollection,System.Boolean)">
            <summary>
            Sets up the DocRecord with owner and CanWrite
            </summary>
            <param name="owner"></param>
            <param name="canWrite"></param>
        </member>
        <member name="M:SEIDR.Doc.DocRecord.#ctor(SEIDR.Doc.DocRecordColumnCollection,System.Boolean,System.Collections.Generic.IList{System.String})">
            <summary>
            Sets up the DocRecord with an owner, CanWrite, and initial content
            </summary>
            <param name="owner"></param>
            <param name="canWrite"></param>
            <param name="ParsedContent"></param>
        </member>
        <member name="P:SEIDR.Doc.DocRecord.CanWrite">
            <summary>
            Sets whether user can update values of the record.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecord.Item(System.String)">
            <summary>
            Gets/sets the column using Column name. Uses the column collection's default alias
            <para>Can only set the column if <see cref="P:SEIDR.Doc.DocRecord.CanWrite"/> is true.</para>
            </summary>        
            <param name="ColumnName"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocRecord.Item(System.String,System.String)">
            <summary>
            Gets/sets the column using alias + Column name.
            <para>Can only set the column if <see cref="P:SEIDR.Doc.DocRecord.CanWrite"/> is true.</para>
            </summary>
            <param name="alias"></param>
            <param name="ColumnName"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocRecord.Item(SEIDR.Doc.DocRecordColumnInfo)">
            <summary>
            Gets/sets the value associated with the column
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocRecord.Item(System.Int32)">
            <summary>
            Getter/setter using index of the columns
            </summary>
            <param name="columnIndex"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.DocRecordColumnCollection">
            <summary>
            Document column information for doc reader/writer
            </summary>
        </member>
        <member name="F:SEIDR.Doc.DocRecordColumnCollection.TextQualifier">
            <summary>
            Text qualifier
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.Merge(System.String,SEIDR.Doc.DocRecordColumnCollection,SEIDR.Doc.DocRecordColumnCollection)">
            <summary>
            Merges the two column collections and returns a new collection with the specified alias
            </summary>
            <param name="newAlias"></param>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.NullIfEmpty">
            <summary>
            Default value for new columns' <see cref="P:SEIDR.Doc.DocRecordColumnInfo.NullIfEmpty"/>. Default is true
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.Merge(SEIDR.Doc.DocRecordColumnCollection,SEIDR.Doc.DocRecordColumnCollection)">
            <summary>
            Merges the two column collections
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.Count">
            <summary>
            Number of columns in the collection
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.MaxLength">
            <summary>
            If in fixed width mode, returns the max size of a record, based on the widths of columns.
            <para>May return -1 if one of the columns is not valid for fixed width mode (<see cref="P:SEIDR.Doc.DocRecordColumnCollection.Valid"/> will be false)</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.ParseRecord(System.Boolean,System.String)">
            <summary>
            Parses a DocRecord out of the string. The string should end at <see cref="P:SEIDR.Doc.DocRecordColumnCollection.LineEndDelimiter"/>, but not include it.
            </summary>
            <param name="writeMode"></param>
            <param name="record"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.ThrowExceptionColumnCountMismatch">
            <summary>
            If true, throws an exception if the size of a record is too big or too small, based on number of records.
            <para>If false, ignores extra columns, and missing columns are treated as null</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.#ctor">
            <summary>
            Creates a basic set up
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.IndexOf(SEIDR.Doc.DocRecordColumnInfo)">
            <summary>
            Checks for the index of the column
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.#ctor(System.Char,System.Collections.Generic.IList{SEIDR.Doc.DocRecordColumnInfo})">
            <summary>
            Sets up for specified delimiter and pre-populated column list
            </summary>
            <param name="Delimiter"></param>
            <param name="columns"></param>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.#ctor(System.Collections.Generic.IList{SEIDR.Doc.DocRecordColumnInfo})">
            <summary>
            Attempts to set up for fixed width columns with prepopulated list
            </summary>
            <param name="columns"></param>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.CanUseAsFixedWidth">
            <summary>
            True if the collection is valid for use as FixedWidth
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.LineEndDelimiter">
            <summary>
            Use in delimited mode. If not set, uses Environment.NewLine. 
            <para>Last column in fixed width will not end early on reaching the value.</para>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.FixedWidthMode">
            <summary>
            Sets whether the columns should be used for fixed width or delimited
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.SetDelimiter(System.Char)">
            <summary>
            Sets the delimiter to thenew character
            </summary>
            <param name="Delimiter"></param>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.RemoveDelimiter">
            <summary>
            Removes the delimiter. Will not allow collection to be used for delimited
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.Delimiter">
            <summary>
            Specifies the character that should separate characters
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.Valid">
            <summary>
            Usable for doc writing/reading
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.Alias">
            <summary>
            Default alias for new columns
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.Item(System.String)">
            <summary>
            Grabs the first column whose column name matches, and whose alias matches <see cref="P:SEIDR.Doc.DocRecordColumnCollection.Alias"/>
            </summary>
            <param name="ColumnName"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.Item(System.String,System.String)">
            <summary>
            Access Column info for specific column/alias
            </summary>
            <param name="SpecificAlias"></param>
            <param name="ColumnName"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnCollection.Item(System.Int32)">
            <summary>
            Access columns by index. Also the indexer that allows updating columns.
            </summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.AddColumn(System.String,System.Nullable{System.Int32},System.String)">
            <summary>
            Adds a new column and returns its index
            </summary>
            <param name="ColumnName"></param>
            <param name="MaxSize"></param>
            <param name="EarlyTerminator">For use with fixed width. Allows ending the column early. E.g. NewLine</param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.UpdateColumn(System.String,System.String,System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean})">
            <summary>
            Updates the column information specified by column name, under this collection's <see cref="P:SEIDR.Doc.DocRecordColumnCollection.Alias"/>
            </summary>
            <param name="ColumnName"></param>
            <param name="newName"></param>
            <param name="MaxSize"></param>
            <param name="EarlyTerminator"></param>
            <param name="nullIfEmpty">If set, overrides the column value. If null, leaves the column's value alone</param>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.UpdateColumn(System.String,System.String,System.String,System.Nullable{System.Int32},System.String,System.Nullable{System.Boolean})">
            <summary>
            Updates the column information specified by the Alias/column Name
            </summary>
            <param name="Alias"></param>
            <param name="ColumnName"></param>
            <param name="newName"></param>
            <param name="MaxSize"></param>
            <param name="EarlyTerminator"></param>
            <param name="NullIfEmpty">If set, overrides the column value. If null, leaves the column's value alone</param>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.AddColumn(SEIDR.Doc.DocRecordColumnInfo)">
            <summary>
            Adds the set up column to the collection
            </summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnCollection.CheckForFixedWidthValid">
            <summary>
            Checks if the object can be used for fixed width. 
            <para>Should be used if setting column information via indexers</para>
            </summary>
        </member>
        <member name="T:SEIDR.Doc.DocRecordColumnInfo">
            <summary>
            Column information for Doc Reader/Writer
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnInfo.NullIfEmpty">
            <summary>
            If true, a value matching <see cref="F:System.String.Empty"/> will be treated as null.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnInfo.MaxLength">
            <summary>
            Maximum width of the column when used with fixed width
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnInfo.EarlyTerminator">
            <summary>
            For use with fixed width, cause column to end early. 
            <para>E.g., final column ends as soon as it reaches a newline instead of after <see cref="P:SEIDR.Doc.DocRecordColumnInfo.MaxLength"/> characters</para>
            <para>Note: last column in fixed width should account for the space taken by NewLine</para>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnInfo.ColumnName">
            <summary>
            Name of the column
            </summary>
        </member>
        <member name="P:SEIDR.Doc.DocRecordColumnInfo.OwnerAlias">
            <summary>
            Alias of the column's owner
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.#ctor(System.String,System.String)">
            <summary>
            Creates a new Delimited Record Column info record, for getting information out of a delimited record
            </summary>
            <param name="Column"></param>
            <param name="Alias"></param>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.Equals(System.Object)">
            <summary>
            Check that the columns are referencing the same data
            </summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.op_Equality(SEIDR.Doc.DocRecordColumnInfo,SEIDR.Doc.DocRecordColumnInfo)">
            <summary>
            Check that the alias and column name match
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.op_Inequality(SEIDR.Doc.DocRecordColumnInfo,SEIDR.Doc.DocRecordColumnInfo)">
            <summary>
            Check that the alias or column name do not match
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.GetHashCode">
            <summary>
            Hash code is dependent on column name and alias only
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.ToString">
            <summary>
            ToString, just returns Column Name.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.ToString(System.Boolean)">
            <summary>
            Alternate version of toString.
            </summary>
            <param name="includeAlias">If true and alias is non empty, will be formatted as [Alias].[ColumnName]<para>
            If true and alias is empty/white space, will return [ColumnName]</para><para>
            Otherwise, will return <see cref="M:SEIDR.Doc.DocRecordColumnInfo.ToString"/></para></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocRecordColumnInfo.CreateColumns(System.String,System.String[])">
            <summary>
            Sets up the columns using the same alias and in the same order as the passed parameters
            </summary>
            <param name="Alias"></param>
            <param name="ColumnList"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.DocExtensions">
            <summary>
            Extensions related to documents/files and reading/writing/manipulating content
            </summary>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.SerializeToFile(System.Object,System.String)">
            <summary>
            Overwrite the filepath with the xml content of the object (Basic XML serializer)
            </summary>
            <param name="toFile"></param>
            <param name="FilePath"></param>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.DeSerializeFile``1(System.String)">
            <summary>
            Deserialize the file's content into an instance fo type RT (Basic XML serializer)
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="FilePath"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.SerializeToXML(System.Object)">
            <summary>
            Serialize the object to an XML string and return it (Basic XML serializer)
            </summary>
            <param name="toString"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.DeserializeXML``1(System.String)">
            <summary>
            Attempt to deserialize the XML into an object of type RT. Does not catch exceptions
            <para>Uses Basic XMLSerializer</para>
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="XML"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.GuessDelimiter(System.String)">
            <summary>
            Tries to guess the delimiter of a line string from the following characters: |,\t;:
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.AddAttributes(System.IO.FileInfo,System.IO.FileAttributes[])">
            <summary>
            Add listed attributes to the File and refreshes the FilInfo. Does nothing if the File doesn't exist.
            </summary>
            <param name="f"></param>
            <param name="AttributesToAdd"></param>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.RemoveAttributes(System.IO.FileInfo,System.IO.FileAttributes[])">
            <summary>
            Remove listed attributes from the File and refreshes the FilInfo. Does nothing if the File doesn't exist.
            </summary>
            <param name="f"></param>
            <param name="attributesToRemove"></param>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.ParseDate(System.String,System.String,System.DateTime@)">
            <summary>
            Parses the filename to determine a date that should be associated with it. 
            <para>If a date can be determined, the FileDate out parameter will be set and usable</para>
            </summary>
            <param name="fileName"></param>
            <param name="dateFormat">* For skipping a variable number of misc characters, &lt;MM> for Finding a month, &lt;DD> for finding a day, &lt;YY> for finding year without century, &lt;YYYY> for finding year with century.
            <para>E.g., 'example01_2016_File_12_30' would match 'example01_*&lt;YYYY>_File_&lt;MM>_&lt;DD>' or '*&lt;YYYY>*&lt;MM>_&lt;DD>'. Other numbers in between may cause issues, though. </para> </param>
            <param name="FileDate"></param>
            <returns>True if able to parse a date from the file name using specified format.</returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.CleanLine(System.String)">
            <summary>
            Removes invisible characters from a line of text. Also replaces u0092 with single quote.
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.DocExtensions.SplitOutsideQuotes(System.String,System.Char,System.Char)">
            <summary>
            Splits a string so that delimiters inside quotes do not create extra fields.
            </summary>
            <remarks>Assumes that there are no NULL characters in the string.</remarks>
            <param name="line">Line to be split</param>
            <param name="delimiter">Delimiter to split the file</param>
            <param name="TextQual">Text qualifier. Delimiters between text qualifiers will be kept. Default to '"'</param>
            <returns>Array of strings split by delimiter except where the delimiter is between text qualifiers</returns>
        </member>
        <member name="T:SEIDR.Doc.FAttModder">
            <summary>
            Use to change the attributes of a given File.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.FAttModder.RemoveAttribute(System.String,System.IO.FileAttributes[])">
            <summary>
            Removes any of the listed attributes from the file.
            <para>Throws an exception if the file does not exist.</para>
            </summary>
            <param name="fullFilePath">Full file path for file we want to change attributes on.</param>
            <param name="toRemove">List of FileAttributes to be turned off.</param>
        </member>
        <member name="M:SEIDR.Doc.FAttModder.AddAttribute(System.String,System.IO.FileAttributes[])">
            <summary>
            Adds any of the listed attributes from the file.
            <para>Throws an exception if the file does not exist.</para>
            </summary>
            <param name="fullFilePath">Full file path for file we want to change attributes on.</param>
            <param name="toAdd">List of FileAttributes to be turned on.</param>
        </member>
        <member name="T:SEIDR.Doc.FileSorter">
            <summary>
            Note this has not been tested yet
            </summary>
        </member>
        <member name="M:SEIDR.Doc.FileSorter.#ctor(System.String,System.Int32[],System.Boolean)">
            <summary>
            Sort FileInput based on sortIndexes. Ignore the first line when sorting if the System.IO.File has a header.<para>
            Any lines that do NOT match the standard line length may be dropped or treated in an unpredictable way.
            </para>
            </summary>
            <param name="FileInput"></param>
            <param name="sortIndexes"></param>
            <param name="hasHeader"></param>
        </member>
        <member name="M:SEIDR.Doc.FileSorter.Sort(System.String,System.String,System.Boolean)">
            <summary>
            Return true if a comes before b in the sort
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <param name="physEarly">Set to true if a comes before b in the physical System.IO.File</param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.GroupOn">
            <summary>
            For grouping data that's being processed by a processor. Implicitly gathers some aggregate data from the data when added, based on the type assigned to the GroupOn.
            </summary>
            <remarks>The average aggregation data is not exact and is instead an approximate average ONLY.
            <para>
            The GroupOn should be used consistently with the same fields or groupings of fields. If you are combining fields as a group, you should have an identifier to make sure that there are no cases like '430' + '14' matching '4' + '314'. Depending on the data, it's probably not advisable to combine fields as data unless you're creating a derived field and know what you're doing.
            </para>
            </remarks>
        </member>
        <member name="M:SEIDR.Doc.GroupOn.Matches(SEIDR.Doc.GroupOn)">
            <summary>
            Checks if two groupOns have the same name. Description is ignored actually.
            </summary>
            <param name="g"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.GroupOn.#ctor(System.String,SEIDR.Doc.GroupOn.GroupType,System.String)">
            <summary>
            Constructor + Description
            </summary>
            <param name="GroupName">Name for identifying this object. It should describe the type of data being grouped, with keys being the actual values grouping.</param>
            <param name="type">Type of object action to take when adding a string to the group's data</param>
            <param name="GroupDescription">Optional, extra description to describe the goal of the GroupOn object</param>
        </member>
        <member name="M:SEIDR.Doc.GroupOn.#ctor(System.String,SEIDR.Doc.GroupOn.GroupType)">
            <summary>
            Constructor
            </summary>
            <param name="GroupName">Name for identifying this object. It should describe the type of data being grouped, with keys being the actual values grouping.</param>
            <param name="type">Type of object action to take when adding a string to the group's data</param>
        </member>
        <member name="M:SEIDR.Doc.GroupOn.Compare(SEIDR.Doc.GroupOn,SEIDR.Doc.GroupOn)">
            <summary>
            Compares two GroupOns to see if they 
            </summary>
            <param name="a"></param>
            <param name="b"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.Doc.GroupOn.GroupType">
            <summary>
            How data is stored when you add an item to the group. Also determines the type of object returned when you want to get a dataObject for a given key.
            </summary>
        </member>
        <member name="F:SEIDR.Doc.GroupOn.GroupType.NumRange">
            <summary>
            double[4]: Min, Max, average. Conversion fail
            </summary>
        </member>
        <member name="F:SEIDR.Doc.GroupOn.GroupType.NumSign">
            <summary>
            int[4]: Count less than 0, Count == 0, Count greater than 0, conversion fail
            </summary>
        </member>
        <member name="F:SEIDR.Doc.GroupOn.GroupType.varchar">
            <summary>
            int[2]: Min Length, Max Length
            </summary>
        </member>
        <member name="F:SEIDR.Doc.GroupOn.GroupType.dateType">
            <summary>
            datetime[2]: min date, max date
            </summary>
        </member>
        <member name="F:SEIDR.Doc.GroupOn.GroupType.Record">
            <summary>
            List (string): just holds onto every piece of fieldDate added in a list of strings
            </summary>
        </member>
        <member name="P:SEIDR.Doc.GroupOn.type">
            <summary>
            Numeric representation of internal property '_type'. Mainly used for comparison between groupOn objects
            </summary>
        </member>
        <member name="P:SEIDR.Doc.GroupOn.Name">
            <summary>
            Name representing this groupOn. Mainly used for comparison between groupOn objects
            </summary>
        </member>
        <member name="M:SEIDR.Doc.GroupOn.AddData(System.String,System.String)">
            <summary>
            Adds the content of a string to a data object that matches based on the key( Case insensitive, trimmed spaces).
            <para>Type of object in data depends on the GroupType chosen at construction.</para>
            </summary>
            <param name="key">Key for finding the group/data Object we want to update.</param>
            <param name="fieldData">Content from a line of raw data that we want to use to update the data</param>
        </member>
        <member name="M:SEIDR.Doc.GroupOn.NewData(System.String,SEIDR.Doc.GroupOn.dataObj)">
            <summary>
            Initialize the object inside before adding it to the data list
            </summary>
            <param name="fieldData">Data used to modify object</param>
            <param name="data">Data object to modify</param>
        </member>
        <member name="M:SEIDR.Doc.GroupOn.ToString">
            <summary>
            Override object's ToString
            </summary>
            <returns>String representing the object</returns>
        </member>
        <member name="M:SEIDR.Doc.GroupOn.GetObject(System.String)">
            <summary>
            Gets the data for a specific key. You need to know what type of data it is based on what type of group on you chose.
            <para>Record: List(string), varchar: int[2], dateType: datetime[2], numrange: double[4], numSign: int[4]</para>
            </summary>
            <param name="key">Key for finding the data object holding the data you want.</param>
            <returns>Object containing the data associated with this key.</returns>
        </member>
        <member name="T:SEIDR.Doc.Processor">
            <summary>
            Can be Customized for doing some File Analysis.
            <para>By using the addon boolean, you can create multiple processors to check for different things in a given file.</para>
            <para>You can also use the addon boolean to combine analysis data from multiple files into one final output file.</para>
            <para> </para>
            <para>Run Procedure:</para>
            <para>Initialize Processor. Set things like Name and the AddOn Boolean or AddAdditionalInformation Boolean.</para>    
            <para>Initialize any objects you want to modify during any of the processing methods.</para>
            <para>Anything that can be found by using the indexer[string ReferenceName] will appear in the output report, plus any notes from the updateNote(string referenceName, noteText) method.</para>
            <para>Call The processor's Run method.</para>
            </summary>
            <remarks>
            Custom objects should be fine to use with the indexer as long as they override ToString().
            <para>The first Processor running in a program should have Addon set to false(the Default). An existing file will then be moved so that only data from your processors are in the same file. Header information can be added using the ReportHeader string array.</para>
            <para>The quick reader used by Processor will not provide Line Endings to the user. Any line ending analysis would require a custom reading of the file, or a different initiation the quick reader. In both cases, this means that the Processor class would not work for this purpose.</para>
            <para>Use the GroupOn class to organize data along with some premade and implicit aggregation functionality.</para>
            <para>Running multiple processor threads on the same file should technically be safe and not have lock issues, but is untested.</para>
            </remarks>
        </member>
        <member name="P:SEIDR.Doc.Processor.OutputFile">
            <summary>
            Full path of file to be created by processor.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.Processor.ChangeOutputFolder(System.String)">
            <summary>
            Change the output directory of the processor to be the passed directory. Also creates the directory if it doesn't exist already.
            </summary>
            <param name="directory">Path to directory</param>
        </member>
        <member name="F:SEIDR.Doc.Processor.AddOn">
            <summary>
            Set to true to override default behavior and append any data from this processor to the end of the file.
            <para>Default: An existing file will be renamed so that a new file can be created for this processor</para>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.Processor.ProcessorName">
            <summary>
            Used for Identifying Processor Write blocks.
            </summary>
        </member>
        <member name="P:SEIDR.Doc.Processor.Name">
            <summary>
            Used for Identifying Processor Write Blocks. 
            <para>Modifies the value of ProcessorName</para>
            </summary>
        </member>
        <member name="P:SEIDR.Doc.Processor.Item(System.String)">
            <summary>
            Public indexer. Cast values to object to store them. 
            <para>It may be necessary to cast to and from object when modifying values.</para>
            </summary>
            <remarks>
            Custom objects should be fine as long as they override ToString.
            </remarks>
            <param name="ReferenceName">Column name or parameter for grouping an object.</param>
            <returns>Value of object stored or null if it doesn't exist</returns>
        </member>
        <member name="M:SEIDR.Doc.Processor.GetString(System.String)">
            <summary>
            String version of getter. Will return null if the reference has not been created.
            </summary>
            <param name="ReferenceName"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.Processor.Has(System.String)">
            <summary>
            Returns true if the given reference name has an associated value.
            </summary>
            <param name="referenceName"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.Processor.GetDouble(System.String)">
            <summary>
            Attempts to find the reference. returns 0 if the reference doesn't exist or if it's not a double.
            </summary>
            <param name="referenceName"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.Processor.GetGroup(System.String)">
            <summary>
            GroupOn version of getter. Will return null if the reference has not been created.
            </summary>
            <param name="referenceName"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.Processor.SetAggregates(System.String[])">
            <summary>
            Mark objects in processor as aggregate.
            </summary>
            <param name="ReferenceNames">List of object names to mark aggregate</param>
        </member>
        <member name="M:SEIDR.Doc.Processor.GetLong(System.String)">
            <summary>
            Long version of getter. Returns 0 if not set. The value of the object if you try to get it via the indexer will still be null though.
            </summary>
            <param name="referenceName"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.Processor.GetInt(System.String)">
            <summary>
            int version of getter. Returns 0 if not set. The value of the object if you try to get it via the indexer will still be null though.
            </summary>
            <param name="referenceName"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.Doc.Processor.defaultGet">
            <summary>
            Default datetime for GetDate(string)
            </summary>
        </member>
        <member name="M:SEIDR.Doc.Processor.GetDate(System.String)">
            <summary>
            Datetime version of getter. Returns the value of defaultGet if the value has not been set yet
            </summary>
            <param name="referenceName"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.Processor.Remove(System.String)">
            <summary>
            Removes a custom object from the results that will be in the output.
            </summary>
            <param name="referenceName">Column name or parameter for grouping an object.</param>
        </member>
        <member name="M:SEIDR.Doc.Processor.UpdateNote(System.String,System.String)">
            <summary>
            Update any notes associated with ReferenceName. It is not necessary to worry about formatting, that is already handled.
            <para>**NOTE:You cannot clear or remove values from the notes**</para>
            </summary>
            <param name="ReferenceName">Reference name. Matches the indexer. Must already exist.</param>
            <param name="NoteText">Notes associated with the reference name. Will be included in output</param>
        </member>
        <member name="P:SEIDR.Doc.Processor.RecordCount">
            <summary>
            Gets the record count. Headers and empty lines are not included.
            </summary>
        </member>
        <member name="F:SEIDR.Doc.Processor.ReportHeader">
            <summary>
            ReportHeader[0] = File Description
            <para>
            ReportHeader[...] = Section Names
            </para>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.Processor.Process">
            <summary>
            Process function to apply to every line.
            <para>Can be used to update the underlying values stored and accessed by the indexer in order to get some automated analysis on a file.</para>
            <para>Can be set to point to any void function that takes a string as a parameter</para>
            <para>The pointed function can also include running a ProcessEventHolder on the line after splitting by delimiter.</para>
            <para>Default: Point to null(Does nothing)</para>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.Processor.ProcessHeader">
            <summary>
            Will be called on the first non empty string unless it's null or FileHasHeader is set to false
            <para>Default: Point to null</para>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.Processor.PostProcess">
            <summary>
            Will be called at the end of the processor's run. Can be used to add additional information/notes based on analysis of the various objects
            <para>Takes no parameters or points to a parameterless void function.</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.Processor.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Constructor. Allows choice for output file's path
            <para>Any existing copy of the output file will be renamed to have its rename time at the end of its name, unless AddOn is set to true</para>
            </summary>
            <param name="FilePath">Full path to File to be analyzed</param>
            <param name="OutputPath">Full path to output analysis file.</param>
            <param name="Append">If true, add on to the file if it exists. Else rename any existing copy of a file at OutputPath</param>
        </member>
        <member name="M:SEIDR.Doc.Processor.#ctor(System.String)">
            <summary>
            Default Constructor. Output File with any analysis will be the given file and added extension of ".ilxp"
            <para>Any existing copy of the file will be renamed to have its rename time at the end of its name, unless AddOn is set to true</para>
            </summary>
            <param name="FilePath">Path to file to be analyzed</param>
        </member>
        <member name="M:SEIDR.Doc.Processor.#ctor(System.String,System.String[])">
            <summary>
            Constructor. Requires an output path but allows you to run multiple files through a single Processor
            <para>Example construction: Processor p = new Processor("C:/User/Test/Result.ilx", "C:/User/Test/Test1.txt", "C:/User/Test/Test2.txt",...)</para>
            </summary>
            <param name="outputFile">Path to file that will contain results</param>
            <param name="inputFiles">List of filepaths to run the processor on. This is params so it can be passed as a string[] or as a number of strings as separate parameters</param>
        </member>
        <member name="M:SEIDR.Doc.Processor.#ctor(System.String,System.Data.DataTable)">
            <summary>
            Run on the results of a query instead of a file.
            </summary>
            <param name="outputFile">File to contain any results</param>
            <param name="table">DataSet filled by a query</param>
        </member>
        <member name="M:SEIDR.Doc.Processor.ReInit(System.String,System.String[])">
            <summary>
            Restart the file settings in order to be able to do a new run.
            </summary>
            <param name="outputFile"></param>
            <param name="inputFiles"></param>
        </member>
        <member name="M:SEIDR.Doc.Processor.Reinit(System.String,System.Data.DataTable)">
            <summary>
            Restart using a DataSet as the data source for run
            </summary>
            <param name="outputFile"></param>
            <param name="table"></param>
        </member>
        <member name="F:SEIDR.Doc.Processor.FileHasHeader">
            <summary>
            Set to false if the file does not contain a header.
            <para> If true, ProcessHeader will be called on the first line, or it will be skipped if ProcessHeader is null</para>
            <para>Default: True.</para>
            </summary>
        </member>
        <member name="M:SEIDR.Doc.Processor.Run">
            <summary>
            Read each line of the file and processes it using the methods pointed to by Process and ProcessHeader
            <para>PostProcess is run at the end if it has been set to point to a non null method.</para>
            </summary>
            <remarks>
            An exception will be thrown if Process still points to null when this is run.
            </remarks>
        </member>
        <member name="F:SEIDR.Doc.Processor.ProcessData">
            <summary>
            Point to a method that processes a data row.
            <para>You should be able to either keep data in an object provided by the Processor's value holder(and will appear in the output), or an outside variable for your own methods and post process analysis.</para>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.Processor.PostProcessData">
            <summary>
            Use for post processing analysis on the results of a query.
            </summary>
        </member>
        <member name="F:SEIDR.Doc.Processor.lineLength">
            <summary>
            Full length of each line in the output file.
            </summary>
        </member>
        <member name="F:SEIDR.Doc.Processor.NameLength">
            <summary>
            space taken up by variable name in output file. 
            </summary>
        </member>
        <member name="F:SEIDR.Doc.Processor.AddRunTimeInformation">
            <summary>
            Adds additional information about the run at the bottom of a section.
            </summary>
        </member>
        <member name="T:SEIDR.Doc.FileReader">
            <summary>
            FileReader is meant to read lines from a streamreader with the results put into string arrays split on standardized newlines.
            <para>Expectation is that lines will be split by some character, most likely a newline. If the newline is CRLF, will need to set the ChangeLineEndings property to true.
            </para>
            <para>Reading will return an array of strings split by a char</para>
            <para>Standard use:</para> 
            <para>QuickReader qr = new QuickReader(...);</para>
            <para>bool working = true;</para>
            <para> while(working){</para>
            <para> string[] lines = qr.Read(out working);...</para>
            <para>}</para>
            <para>Alternate, need to do something for first block only:</para> 
            <para>string[] lines = qr.Read(out working);</para>
            do{<para>...if (!moreWork)break;</para><para> qr.Read(out working);</para>
            <para>}while(true);</para>
            </summary>
            <remarks>
            <para>Any static methods will act on a single string and assume that there are no line endings inside the string.</para>
            There are also two static methods that are both for splitting lines and keeping any delimiters that are text qualified. 
            </remarks>
        </member>
        <member name="M:SEIDR.Doc.FileReader.SplitOutsideQuotes(System.String,System.Char)">
            <summary>
            Splits a string so that delimiters inside quotes do not create extra fields. Use '"' as Text Qualifier
            </summary>
            <remarks>Assumes that there is no line ending in the string.</remarks>
            <param name="line">Line to be split</param>
            <param name="delimiter">Delimiter to split the file</param>
            <returns>Array of strings split by delimiter except where the delimiter is between text qualifiers</returns>
        </member>
        <member name="M:SEIDR.Doc.FileReader.CleanLine(System.String)">
            <summary>
            Removes invisible characters from a line of text. Also replaces u0092 with single quote.
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.FileReader.SplitOutsideQuotes(System.String,System.Char,System.Char)">
            <summary>
            Splits a string so that delimiters inside quotes do not create extra fields.
            </summary>
            <remarks>Assumes that there is no line ending in the string.</remarks>
            <param name="line">Line to be split</param>
            <param name="delimiter">Delimiter to split the file</param>
            <param name="TextQual">Text qualifier. Delimiters between text qualifiers will be kept</param>
            <returns>Array of strings split by delimiter except where the delimiter is between text qualifiers</returns>
        </member>
        <member name="F:SEIDR.Doc.FileReader.defaultBlock">
            <summary>
            Value used by newly created quickreader objects as the block size
            </summary>
        </member>
        <member name="P:SEIDR.Doc.FileReader.block">
            <summary>
            Sets the number of characters to try to read per call of Read.
            <para>
            Minimum value: 1000. An error will not be thrown if you try to set it to less, but the value will just be set to 1000 instead.
            </para>
            <remarks>
            Note that reading less characters than the size of the block is not a problem. 
            <para>Rather, reading fewer characters than the block size is the way to know that we're done with the file.
            </para>
            </remarks>
            </summary>
        </member>
        <member name="F:SEIDR.Doc.FileReader.TrimQuotes">
            <summary>
            Set to true to remove all quotes.
            </summary>
        </member>
        <member name="F:SEIDR.Doc.FileReader.CleanInvisibles">
            <summary>
            Set to true to remove invisible characters like form feed or null
            </summary>
        </member>
        <member name="P:SEIDR.Doc.FileReader.splitter">
            <summary>
            Character to split lines on.         
            </summary>
        </member>
        <member name="P:SEIDR.Doc.FileReader.ChangeLineEnding">
            <summary>
            If true, change all groups of line endings to a single LF. Else try to read as is.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.FileReader.#ctor(System.String,System.Char)">
            <summary>
            Constructor with custom splitter
            </summary>
            <param name="path">File path to read</param>
            <param name="separator">Character to split lines on. If you want to split on line endings and need more than one character, you'll need to set ChangeLineEnding and then use '\n'.
            <para>If you want to split manually, I would suggest splitting by line endings and using '\n', then joining on '\n' and then doing your custom split.</para></param>
        </member>
        <member name="P:SEIDR.Doc.FileReader.FilePath">
            <summary>
            Full Path to file being read.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.FileReader.#ctor(System.String,System.Char,System.Boolean)">
            <summary>
            Constructor with option to set whether to lock on read
            </summary>
            <param name="path"></param>
            <param name="separator"></param>
            <param name="readlock">If true, lock the file while open.</param>
        </member>
        <member name="M:SEIDR.Doc.FileReader.#ctor(System.String,System.Boolean)">
            <summary>
            QuickReader with a Write lockif the boolean is true.
            </summary>
            <param name="path">Path of file to read</param>
            <param name="WriteLock">If true, prevent the file from being modified by taking the write lock.</param>
        </member>
        <member name="M:SEIDR.Doc.FileReader.#ctor(System.String)">
            <summary>
            Constructor. Default splitter is '\n'.
            </summary>
            <param name="path">File path to read</param>
        </member>
        <member name="M:SEIDR.Doc.FileReader.Finalize">
            <summary>
            Deconstructor.
            </summary>
        </member>
        <member name="M:SEIDR.Doc.FileReader.Read(System.Int32@,System.Boolean@)">
            <summary>
            Reads up to (default) 1000000 characters from the file and returns an array of strings split by the separator. Will remove the final string unless a non full block was read.
            <para>If this method is called after the file finishes reading, an Exception will be thrown.</para>
            </summary>
            <param name="work">Number of characters read from the file. Does not necessarily match the number of characters in the joined string[]</param>
            <param name="moreWork">Whether or not there are more characters in the file to read. Equivalent to checking if work is less than the block size.</param>
            <returns>Split lines from the file.</returns>
        </member>
        <member name="M:SEIDR.Doc.FileReader.Read(System.Boolean@)">
            <summary>
            Reads up to (default) 1000000 characters from the file and returns an array of strings split by the separator. Will remove the final string unless a non full block was read.
            <para>If this method is called after the file finishes reading, an Exception will be thrown.</para>
            </summary>
            <param name="moreWork">True if there is (probably) more content to read from the file. It would also be set to true if the file happened to end filling up a block.</param>
            <returns>Split string of lines containing the read characters. Split default is '\n' but can be changed with one of the constructors.</returns>
        </member>
        <member name="M:SEIDR.Doc.FileReader.Read(System.Int32@)">
            <summary>
            Reads up to (default) 1000000 characters from the file and returns an array of strings split by the separator. Will remove the final string unless a non full block was read.
            <para>If this method is called after the file finishes reading, an Exception will be thrown.</para>
            </summary>
            <param name="work">The number of characters read. There's more to read in the file as long as this is equal to the size of the block(1000000).
            <para>Does not account for characters added or subtracted from removing quotes or holding to keep only full lines in the strings contained in the array</para>
            <para>If the value is less than the QuickReader's block size, there is no more work to do.
            </para>
            </param>
            <returns>Split string of lines from the file.</returns>
        </member>
        <member name="M:SEIDR.Doc.FileReader.GuessDelimiter(System.String)">
            <summary>
            Tries to guess the delimiter of a line string from the following characters: |,\t;:
            </summary>
            <param name="line"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.Doc.FileReader.CleanLine(System.String,System.Boolean)">
            <summary>
            Cleans a single line using the method from validate clean.
            </summary>
            <param name="line">Line to clean</param>
            <param name="combineNewlines">If true, all groups of newline characters will be replaced by a single LF</param>
            <returns>Cleaned line</returns>
        </member>
        <member name="M:SEIDR.Doc.FileReader.Dispose">
            <summary>
            Disposes the underlying stream.
            </summary>
        </member>
        <member name="T:SEIDR.LikeExpressions">
            <summary>
            Used for comparing strings using a sql WildCard '%' and '_'. Also for:
            <para>* Finding the first or last occurance of such a string in an array of strings</para>
            <para>* Finding the first substring occurrence of a condition within a single string. (Other methods match condition against ENTIRE string)</para>
            </summary>
            <remarks>For Reference, the Original Intended use is to use this to find column names in the header of a file that match a pattern like 'ac%t' and use that index in a Processor in order to make a generic report generator for a given type of file.</remarks>
        </member>
        <member name="F:SEIDR.LikeExpressions.AllowRegex">
            <summary>
            If true, will not escape regex special characters, allowing you to take advantage of regex in your calling method.
            </summary>
        </member>
        <member name="M:SEIDR.LikeExpressions.SearchStringWithCase(System.String,System.String)">
            <summary>
            Checks for the substring within the full line that matches the condition of a like Statement. Requires matching case
            </summary>
            <param name="fullLine">Full string to check</param>
            <param name="condition">LIKE Condition</param>        
            <returns>First occurrence of a substring of fullLine that matches condition, or null.</returns>
        </member>
        <member name="M:SEIDR.LikeExpressions.SearchString(System.String,System.String)">
            <summary>
            Checks for the substring within the full line that matches the condition of a like Statement. Ignores case.
            </summary>
            <param name="fullLine">Full string to check</param>
            <param name="condition">LIKE Condition</param>        
            <returns>First occurrence of a substring of fullLine that matches condition, or null.</returns>
        </member>
        <member name="M:SEIDR.LikeExpressions.Compare(System.String,System.String)">
            <summary>
            Checks if a string fits a comparison check using the SQL WildCards '%' and '_'. Case is ignored.
            </summary>
            <param name="line">Line to check.</param>
            <param name="comparison">What would go in the LIKE expression</param>
            <returns>True if it passes the comparison, false otherwise</returns>
        </member>
        <member name="M:SEIDR.LikeExpressions.CompareWithCase(System.String,System.String)">
            <summary>
            Checks if line is LIKE comparison, case sensitive.
            </summary>
            <param name="line">String we want to find a match for comparison in</param>
            <param name="comparison">Value we want to find inside line</param>
            <returns>True if line is LIKE comparison,  false otherwise</returns>
        </member>
        <member name="M:SEIDR.LikeExpressions.Compare(System.String[],System.String)">
            <summary>
            Goes through each string in lines to find the first string that matches comparison.
            </summary>
            <param name="lines">Array of Lines to check for a match with comparison</param>
            <param name="comparison">What would go in a LIKE statement</param>
            <returns>Index of First string in lines that matches comparison. Returns -1 if no match is found.</returns>
        </member>
        <member name="M:SEIDR.LikeExpressions.ReverseCompare(System.String[],System.String)">
            <summary>
            Performs Compare in the opposite order on the line.
            </summary>
            <param name="lines">Array of Lines to check for a match with comparison</param>
            <param name="comparison">What would go in a LIKE statement</param>
            <returns>Index of Last string in lines that matches comparison. Returns -1 if no match is found.</returns>
        </member>
        <member name="M:SEIDR.LikeExpressions.ReverseCompare(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Performs compare in the opposite order, returns the first string from the Enumerable that matches
            </summary>
            <param name="lines"></param>
            <param name="Comparison"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.LikeExpressions.GetMatches(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Searches an array of strings to find all strings that match comparison
            </summary>
            <param name="lines">Array of strings to search</param>
            <param name="comparison">Comparison that can include the % wildcard</param>
            <returns>Array containing all strings that match comparison</returns>
        </member>
        <member name="T:SEIDR.Mailer">
            <summary>
            Wrapper for sending mail messages
            </summary>
        </member>
        <member name="P:SEIDR.Mailer.SendTo">
            <summary>
            Recipients of email
            </summary>
        </member>
        <member name="P:SEIDR.Mailer.SMTPServer">
            <summary>
            The SMTP Server that your mailer connects to. E.g. gmail.com
            </summary>
        </member>
        <member name="P:SEIDR.Mailer.Domain">
            <summary>
            Domain, e.g. gmail, gmail.com, @gmail.com
            <para>Stored without the '@'</para>
            </summary>
        </member>
        <member name="F:SEIDR.Mailer.sender">
            <summary>
            Name of the sender. Will have Domain added when sending if there is no '@'
            </summary>
        </member>
        <member name="M:SEIDR.Mailer.#ctor(System.String,System.String)">
            <summary>
            Constructor. Requires name of application for in the eventthat the DS_Application_Settings table is used
            </summary>
            <param name="mailSender">Name of the sender to use</param>
            <param name="SendTo">Recipient of emails</param>
        </member>
        <member name="M:SEIDR.Mailer.SendMailAlert(System.String,System.String,System.Boolean,System.String)">
            <summary>
            Sends a mail from the specified sender
            <para>Will send to the mail list specified by SendTo</para>
            <para>Note: If sender or SMTP Server is null, will return immediately.</para>
            </summary>
            <param name="subject">Email's subject line</param>
            <param name="MailBody">Content making up the email's body.</param>
            <param name="isHtml">If true, sends as an HTML mail</param>
            <param name="recipient">Allow for overriding the SendToList without overriding for overall</param>
        </member>
        <member name="M:SEIDR.META.NestedTokenNode.LoopNodes">
            <summary>
            Depth first loop through Children
            </summary>
            <returns></returns>
        </member>
        <member name="M:SEIDR.META.ObjectExtensions.ToTable(System.Collections.Generic.IEnumerable{System.Object},System.String,System.String[])">
            <summary>
            Converts the IEnumerable of objects to a dataTable with the specified name.
            </summary>
            <param name="obj"></param>
            <param name="Name"></param>
            <param name="propertyList"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.META.ObjectExtensions.CreateInstance``1(System.Data.DataRow)">
            <summary>
            Converts the datarow into an instance of type RT. Requires a parameterless constructor
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="source"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.META.ObjectExtensions.CreateDataRow``1(``0)">
            <summary>
            Creates a datarow from the given record
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="Record"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.META.ObjectExtensions.CreateDataRowView``1(``0)">
            <summary>
            Creates a DataRowView from the given record.
            </summary>
            <typeparam name="RT"></typeparam>
            <param name="Record"></param>
            <returns></returns>
        </member>
        <member name="T:SEIDR.META.Tokenizer">
            <summary>
            Separates records into tokens. 
            <para>Note(Special Tokens): colon, commas, semicolon, period, brackets, parenthesis are considered their own tokens by default.
            </para>
            <para>Note that this is an IEnumerable so you can either use the peek/GetNext, or you can simply use the tokenizer in a foreach loop.</para>
            </summary>
        </member>
        <member name="M:SEIDR.META.Tokenizer.MergeUntil(System.String@,System.String,System.Boolean)">
            <summary>
            Merges the following tokens until reaching a 'tokenUntil' token.
            </summary>
            <param name="combineString"></param>
            <param name="tokenUntil"></param>
            <param name="appendToken">Adds the combine until token to the CombineString</param>
        </member>
        <member name="M:SEIDR.META.Tokenizer.#ctor(System.String)">
            <summary>
            Creates an instance ofa Tokenizer that separates the string into tokens based on spaces. Also separates special characters into their own token
            </summary>
            <param name="content"></param>
        </member>
        <member name="M:SEIDR.META.Tokenizer.#ctor(System.String,System.Boolean,System.Char[])">
            <summary>
            Creates an instance of a Tokenizer but overrides the list of default characters to treat as tokens.
            </summary>
            <param name="content"></param>
            <param name="includeDefaultSpecialTokens">If true, will include the default special tokens (,.[];</param>
            <param name="specialTokenList"></param>
        </member>
        <member name="M:SEIDR.META.Tokenizer.HandleDefaultSpecialTokens(System.String)">
            <summary>
            Surrounds default special token characters with spaces so that they are separated into their own spot when splitting by space
            </summary>
            <param name="temp"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.META.Tokenizer.GetTokens(System.String)">
            <summary>
            Takes the passed string and extracts a list of tokens from it
            </summary>
            <param name="s"></param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.META.Tokenizer.GetTokens(System.String,System.Char[],System.Boolean)">
            <summary>
            Takes teh passed content string and extracts a lsit of tokens from it.
            <para>Also treats the passed list of characters as special tokens.</para>
            </summary>
            <param name="s"></param>
            <param name="specialTokens"></param>
            <param name="includeDefaultSpecialTokens">If true, will continue to treat the default special tokens as special tokens (see class description)       
            </param>
            <returns></returns>
        </member>
        <member name="M:SEIDR.META.Tokenizer.GetNextToken">
            <summary>
            Gets the next token
            </summary>
            <returns></returns>
        </member>
        <member name="P:SEIDR.META.Tokenizer.HasMoreTokens">
            <summary>
            Check if there are more tokens to look at
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.Batch.BatchTypeCode">
            <summary>
            For some thread control stuff. And file limiting, etc. 
            <para>BatchType Table also contains a description for the type of files expected to be used
            </para>
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.Batch.ThreadID">
            <summary>
            Depend on Operation + BatchType + Profile. If Operation/BatchType/Profile do not set, will be picked by whatever Thread has open spots in its queue and updated
            </summary>
        </member>
        <member name="M:SEIDR.OperationServiceModels.Batch.SetMissingThreadID(System.Byte)">
            <summary>
            Sets the ThreadID on the batch if it's missing/null
            </summary>
            <param name="ID"></param>
        </member>
        <member name="P:SEIDR.OperationServiceModels.Batch.Step">
            <summary>
            The current step number - determines the operation + parameters.
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.Batch.CurrentStep">
            <summary>
            Current step number stored in raw table. Returns <see cref="P:SEIDR.OperationServiceModels.Batch.Step"/>, which is used by view
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.Batch.AttemptCount">
            <summary>
            Number of attempts on the operation/step. Will be incremented each time work starts.
            <para>Begins at 1 for the first attempt.</para>
            <para>Resets when the status/Current step change</para>
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.Batch.Version">
            <summary>
            Operation's Version.
            </summary>
        </member>
        <member name="M:SEIDR.OperationServiceModels.Batch.Register(SEIDR.DataBase.DatabaseManager,System.Int32,System.Collections.Generic.List{SEIDR.OperationServiceModels.Batch_File},System.Collections.Generic.IEnumerable{SEIDR.OperationServiceModels.Batch_File}@)">
            <summary>
            Register the list of Batch_File records with the profile. Returns the first batch. 
            <para>Consider passing to an Operator thread if the corresponding one is free. 
            </para><para>(Should include a bool on the worker indicating it's free, also locking. </para>
            <para>Be able to set the batch so that it starts doing work instead of querying database for work.)</para>
            </summary>
            <param name="mgr"></param>
            <param name="BatchProfileID"></param>
            <param name="fileList">List of Batch_Files to be created by a File Watcher</param>
            <param name="rejected">Files that were not added to any batches as a result of hash or path matching originals of Batch_File's already in use</param>
            <returns>First batch registered with the files, or null</returns>
        </member>
        <member name="M:SEIDR.OperationServiceModels.Batch.AddFile(System.String,System.Nullable{System.DateTime})">
            <summary>
            If the file exists and is not already in the batch, add it to the batch.
            </summary>
            <param name="FilePath"></param>
            <param name="FileDate">Specifies file date - file creation time will be used if not provided</param>
        </member>
        <member name="M:SEIDR.OperationServiceModels.Batch.AddFile(System.IO.FileInfo,System.Nullable{System.DateTime})">
            <summary>
            If the file exists and the path is not in the batch yet, add it to the batch.
            </summary>
            <param name="FilePath"></param>
            <param name="FileDate">Specifies file date - file creation time will be used if not provided</param>
        </member>
        <member name="M:SEIDR.OperationServiceModels.Batch.DeleteFile(System.String)">
            <summary>
            Removes the file - will be applied when the batch status is updated.
            </summary>
            <param name="FilePath"></param>
        </member>
        <member name="P:SEIDR.OperationServiceModels.BatchProfile.ScheduleID">
            <summary>
            TODO: set up Schedule object... Use would be in the DB, though, just calling a proc to create Batches as needed
            </summary>
        </member>
        <member name="T:SEIDR.OperationServiceModels.BATCHSTATUS">
            <summary>
            Descriptions of the base BatchStatuses. If an operation tries to pass an invalid status, then a base status will be chosen depending on
            whether it was expected to be success or failure.
            <para>E.g., trying to pass a failure status after returning true from operation will result in either 'S' or 'C'</para>
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.WORKING">
            <summary>
            Status set when the batch has been picked up for adding to the work queue.
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.COMPLETE">
            <summary>
            Status set when the Batch is done with all steps
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.COMPLETE_INVAlID">
            <summary>
            Status set when the batch is done with all steps but finished with either an error status or entries in the Error Log
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.REGISTERED">
            <summary>
            Status Set when Batch is created by a schedule
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.REGISTERED_FILES">
            <summary>
            Status set when batch has been created by registering files
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.STOP_REQUESTED">
            <summary>
            Status set when a user wants to stop a Batch. 
            <para>If the step completes anyway, will go to either 'X' or 'CE', depending on the presence of additional steps
            </para>
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.STOP_ACKNOWLEDGED">
            <summary>
            Status set when the Operation Stopper has found the batch
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.STOP_FULFILLED">
            <summary>
            Status set when the worker has been force-stopped.
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.INVALID_SEQUENCE">
            <summary>
            Status set when the Batch is not in sequence
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.WORKING_ERROR">
            <summary>
            Status set when the batch execution failed.
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.INVALID_STOP">
            <summary>
            Status to be set when the Parameters are invalid or the batch is otherwise not valid for use with an operation.        
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.STEP_SUCCESS">
            <summary>
            Single step has been completed successfully
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.PARTIAL_SUCCESS">
            <summary>
            Single step has been partially completed, but can still move on to the next operation without finishing completely
            </summary>
        </member>
        <member name="F:SEIDR.OperationServiceModels.BATCHSTATUS.SKIP_STEP">
            <summary>
            Step should be skipped without doing work. E.g., an operation should only be done in exceptional cases
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.Batch_File.FileName">
            <summary>
            Just the fileName of the Batch_File, rather than full path
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.Batch_File.FilePath">
            <summary>
            Full path of file.
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.Batch_File.Exists">
            <summary>
            Gets whether or not a file exists at the current FilePath specified
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.IOperatorManager.PauseEvent">
            <summary>
            Call PauseEvent.WaitOne() to prevent doing work when service is supposed to be paused.
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.IOperatorManager.BatchSize">
            <summary>
            Max number of batches to select at a time
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.IOperatorManager.QueueLimitMargin">
            <summary>
            Extra space for WorkQueue - Batch/Work queue limit determined by BatchSize + Margin
            </summary>
        </member>
        <member name="M:SEIDR.OperationServiceModels.Operator.AddBatches(System.Collections.Generic.IEnumerable{SEIDR.OperationServiceModels.Batch})">
            <summary>
            Add batches to a list - to be used by cancellation and/or Executor Operators. Queue may be able to use profile off of it?
            </summary>
            <param name="batchList"></param>
        </member>
        <member name="M:SEIDR.OperationServiceModels.iOperation.Execute(SEIDR.OperationServiceModels.Batch,System.Data.DataSet,System.String@)">
            <summary>
            Executes the Operation.
            </summary>
            <param name="b">Batch to execute. Contains a list of file objects</param>
            <param name="parameters">Results of calling the procedure from meta data. May be null.</param>
            <param name="BatchStatus">Attempt to Override result status. Will be validated.</param>
            <returns>True if completed successfully, else false</returns>
        </member>
        <member name="M:SEIDR.OperationServiceModels.iOperation.GetResultNotification(System.Boolean,System.String)">
            <summary>
            Allow for a specialized status message for notification e-mail. Ok to return null
            </summary>
            <param name="ExecuteResult"></param>
            <param name="BatchStatus"></param>
            <returns></returns>
        </member>
        <member name="P:SEIDR.OperationServiceModels.iOperationMetaData.Operation">
            <summary>
            Name of your operation
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.iOperationMetaData.OperationSchema">
            <summary>
            A namespace for your operation to prvent of overlap. Should not be null, but defaults to 'SEIDR'.
            <para>If parameter select does not include a schema, this will be used for the Schema.</para>
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.iOperationMetaData.Description">
            <summary>
            Description of operation's purpose. 
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.iOperationMetaData.Version">
            <summary>
            Numeric identifier - allow updating the operation while keeping a legacy version intact. Version defaults to 1
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.iOperationMetaData.ThreadID">
            <summary>
            For forcing the Operator service to pass to a specific thread. 
            <para>Default is to use null - set thread based on batch type or profile</para>
            <para>NOTE: If your operation is not thread safe/uses global variables for state, set this to a value between 1 and 15</para>
            <para>If the threadID is zero or too high for the set up, then the operation will be ignored.</para>
            <para>Higher than 4 is better to set on batch types/profiles, rather than on the operation, though</para>
            </summary>
        </member>
        <member name="P:SEIDR.OperationServiceModels.iOperationMetaData.ParameterSelect">
            <summary>
            Procedure to be called by Operator service - the datarow will be passed on along with the batch.
            <para>Should take a @Profile_OperationID (int or bigger) as the primary parameter</para>
            <para>BatchID will also be passed if available as a parameter</para>
            <para>Will be ignored if null or white space</para>
            </summary>
        </member>
        <member name="T:SEIDR.Serialization.UBJsonDocument">
            <summary>
            UBJsonObject for containing other UBJsonObjects. <para>
            Primary target for serializing and deserializing...</para>
            </summary>
        </member>
        <member name="F:SEIDR.ThreadManaging.Lock.NoLock">
            <summary>
            Mostly the same effect as unlocked. Differentiated for intent.
            <para>
            NoLock is for accepting dirty reads, incomplete changes to objects.
            </para>
            <remarks>
            <para>NOTE: A NoLock is still considered a lock and will throw an Exception if you 
            </para>possess a NoLock and try to acquire a new lock.
            </remarks>
            </summary>
        </member>
        <member name="F:SEIDR.ThreadManaging.Lock.Unlocked">
            <summary>
            Default lock value - No lock acquired
            </summary>
        </member>
        <member name="F:SEIDR.ThreadManaging.Lock.Shared">
            <summary>
            Shared allows many threads to look at the same object without having to worry about it being updated.
            </summary>
        </member>
        <member name="F:SEIDR.ThreadManaging.Lock.Exclusive_Intent">
            <summary>
            Exclusive intent will eventually be the same as an exclusive lock but will wait longer for any share locks to finish
            </summary>
        </member>
        <member name="F:SEIDR.ThreadManaging.Lock.Exclusive">
            <summary>
            Exclusive locks are for writing/updating the values of an object
            <para>
            Will wait until all share level locks are released before actually obtaining the lock
            </para>
            </summary>
        </member>
        <member name="T:SEIDR.ThreadManaging.LockManager">
            <summary>
            Creates an object for managing different levels of locking.
            <para>
            This is only useful for multi threading and each thread really needs to have its own lock manager(s).
            </para>
            </summary>
        </member>
        <member name="F:SEIDR.ThreadManaging.LockManager.ShareBoundary">
            <summary>
            A lock below this value is considered 'Share' 
            <para>
            A lock at or above the value is considered exclusive
            </para>
            </summary>
        </member>
        <member name="F:SEIDR.ThreadManaging.LockManager.LockBoundary">
            <summary>
            A lock below this value is considered 'unlocked' and should mainly be used for consistency or if the lock might be changed.
            <para>
            E.g. if the lock is in a variable, and the level of locking depends on other factors.
            </para>
            </summary>
        </member>
        <member name="F:SEIDR.ThreadManaging.LockManager.DefaultTarget">
            <summary>
            The identifier for the default lock manager target
            </summary>
        </member>
        <member name="F:SEIDR.ThreadManaging.LockManager.LockID">
            <summary>
            A unique ID for your LockManager object
            </summary>
        </member>
        <member name="P:SEIDR.ThreadManaging.LockManager.currentTargetLockLevel">
            <summary>
            Allows you to check the current lock level of your LockManager's target.
            <para>
            Could potentially be used in a loop if a thread is really low priority 
            </para><para>
            EX: while( LockManager.currentLockLevel >Lock.Unlocked) or something
            </para>
            </summary>
        </member>
        <member name="P:SEIDR.ThreadManaging.LockManager.MyLock">
            <summary>
            Gets the value of this LockManager's lock.
            <para>
            If setting, will also try to acquire the lock, unless the new value is unlocked. 
            </para><para>
            If the new value is unlocked, nothing will be done.
            </para><remarks>
            Setting the value will also do nothing if the LockManageralready holds a lock.
            </remarks>
            </summary>
        </member>
        <member name="M:SEIDR.ThreadManaging.LockManager.#ctor(System.String,System.UInt32)">
            <summary>
            Constructor.
            <para>Used for sharing or getting exclusive locks on sections based on other sections using the same target.</para>
            </summary>
            <param name="TARGET">Case insensitive</param>
        </member>
        <member name="M:SEIDR.ThreadManaging.LockManager.Release">
            <summary>
            Release your lock. Useful even with nolock in the event that you MIGHT need to change to using a lock later on.
            <para> 
            Also useful even with no lock if you're using a variable to decide the lock level based on other factors
            </para>
            <remarks>
            Will throw an exception if you try to release an already unlocked LockManager.
            </remarks>
            </summary>
        </member>
        <member name="M:SEIDR.ThreadManaging.LockManager.Acquire(SEIDR.ThreadManaging.Lock)">
            <summary>
            Try to acquire a lock.
            <para>
            An exception will be thrown if you try to acquire a lock on a lock manager that already has a lock.
            </para>
            <remarks>
            If you try to acquire Lock.Unlocked, this will simply Release any lock the lock manager might have.
            </remarks>
            </summary>
            <param name="level"></param>
        </member>
        <member name="T:SEIDR.ThreadManaging.LockManagerException">
            <summary>
            Lock Manager Exception. Thrown by the lock manager when there's an issue with a lock trying to be acquired.
            </summary>
        </member>
        <member name="T:SEIDR.UserFriendlyDateRegex">
            <summary>
            Date Regex logic for simple conversion of friendly date regex to replace the information with the provided date information
            </summary>
        </member>
        <member name="M:SEIDR.UserFriendlyDateRegex.Eval(System.String,System.Nullable{System.DateTime})">
            <summary>
            Used for evaluating a style of user friendly date variable, where month, day, and/or year are represented by letters within ankle brackets.        
            <para>Might be useful somewhere. Does not handle offsets</para>
            </summary>
            <param name="s"></param>
            <param name="Evaluation">Use current date if not provided</param>
            <returns></returns>
        </member>
    </members>
</doc>
